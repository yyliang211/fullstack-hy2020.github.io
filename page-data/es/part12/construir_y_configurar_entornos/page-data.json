{"componentChunkName":"component---src-templates-content-template-js","path":"/es/part12/construir_y_configurar_entornos","result":{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>En la sección anterior, usamos dos imágenes base diferentes: ubuntu y node e hicimos un trabajo manual para ejecutar un simple \"¡Hola, mundo!\". Las herramientas y los comandos que aprendimos durante ese proceso nos serán útiles más adelante. En esta sección, aprenderemos a crear imágenes y configurar entornos para nuestras aplicaciones. Comenzaremos con un backend regular de Express/Node.js y lo desarrollaremos con otros servicios, incluida una base de datos MongoDB.</p>\n<h3>Dockerfile</h3>\n<p>En lugar de modificar un contenedor copiando archivos dentro, podemos crear una nueva imagen que contenga la aplicación \"¡Hola, mundo!\". La herramienta para esto es el Dockerfile. Dockerfile es un archivo de texto simple que contiene todas las instrucciones para crear una imagen. Vamos a crear un Dockerfile de ejemplo a partir de la aplicación \"Hello, World!\".</p>\n<p>Si aún no lo hizo, cree un directorio en su máquina y cree un archivo llamado <i>Dockerfile</i> dentro de ese directorio. También coloquemos un <i>index.js</i> que contenga <em>console.log('Hello, World!')</em> al lado del Dockerfile. La estructura de su directorio debería verse así:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── index.js\n└── Dockerfile</code></pre></div>\n<p>Dentro de ese Dockerfile le diremos a la imagen tres cosas:</p>\n<ul>\n<li>Usa node:16 como base para nuestra imagen.</li>\n<li>Incluya el index.js dentro de la imagen, así no necesitaremos copiarlo manualmente en el contenedor</li>\n<li>Cuando ejecutemos el contenedor desde la imagen, use node para ejecutar el archivo index.js.</li>\n</ul>\n<p>Las instrucciones anteriores se traducirán en un Dockerfile básico. La mejor ubicación para colocar este archivo suele ser la raíz del proyecto.</p>\n<p>El archivo <i>Dockerfile</i> resultante se ve así:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./index.js ./index.js</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> node index.js</span></code></pre></div>\n<p>La instrucción FROM le dirá a Docker que la base de la imagen debe ser node:16. La instrucción COPY copiará el archivo <i>index.js</i> de la máquina host al archivo con el mismo nombre en la imagen. La instrucción CMD dice lo que sucede cuando se usa <em>docker run</em>. CMD es el comando predeterminado que luego se puede sobrescribir con el parámetro dado después del nombre de la imagen. Consulte <em>docker run --help</em> si lo olvidó.</p>\n<p>La instrucción WORKDIR se introdujo para garantizar que no interfiramos con el contenido de la imagen. Garantizará que todos los siguientes comandos tendrán <i>/usr/src/app</i> configurado como el directorio de trabajo. Si el directorio no existe en la imagen base, se creará automáticamente.</p>\n<p>Si no especificamos un WORKDIR, corremos el riesgo de sobrescribir archivos importantes por accidente. Si verifica la raíz (<em>/</em>) de la imagen node:16 con <em>docker run node:16 ls</em>, puede notar todos los directorios y archivos que ya están incluidos en la imagen.</p>\n<p>Ahora podemos usar el comando <em>docker build</em> para construir una imagen basada en el Dockerfile. Vamos a modificar el comando con una bandera adicional: <em>-t</em>, esto nos ayudará a nombrar la imagen:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> build <span class=\"token parameter variable\">-t</span> fs-hello-world <span class=\"token builtin class-name\">.</span> \n<span class=\"token punctuation\">[</span>+<span class=\"token punctuation\">]</span> Building <span class=\"token number\">3</span>.9s <span class=\"token punctuation\">(</span><span class=\"token number\">8</span>/8<span class=\"token punctuation\">)</span> FINISHED\n<span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>Entonces, el resultado es \"docker, construya el Dockerfile en este directorio con la etiqueta fs-hello-world \". Puede apuntar a cualquier Dockerfile, pero en nuestro caso, un simple punto significará el Dockerfile en <i>este</i> directorio. Es por eso que el comando termina con un punto. Una vez finalizada la compilación, puede ejecutarla con <em>docker run fs-hello-world</em>.</p>\n<p>Como las imágenes son solo archivos, se pueden mover, descargar y eliminar. Puede enumerar las imágenes que tiene localmente con <em>docker image ls</em>, eliminarlas con <em>docker image rm</em>. Vea qué otro comando tiene disponible con <em>docker image --help</em>.</p>\n<h3>Imagen más significativa</h3>\n<p>Mover un servidor Express a un contenedor debería ser tan simple como mover la aplicación \"¡Hola, mundo!\" dentro de un contenedor. La única diferencia es que hay más archivos. Afortunadamente, la instrucción <em>COPY</em> puede manejar todo eso. Eliminemos index.js y creemos un nuevo servidor Express. Usemos <a href=\"https://expressjs.com/en/starter/generator.html\">express-generator</a> para crear un esqueleto de aplicación Express básico.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ npx express-generator\n  <span class=\"token punctuation\">..</span>.\n  \n  <span class=\"token function\">install</span> dependencies:\n    $ <span class=\"token function\">npm</span> <span class=\"token function\">install</span>\n\n  run the app:\n    $ <span class=\"token assign-left variable\">DEBUG</span><span class=\"token operator\">=</span>playground:* <span class=\"token function\">npm</span> start</code></pre></div>\n<p>Primero, ejecutemos la aplicación para tener una idea de lo que acabamos de crear. Tenga en cuenta que el comando para ejecutar la aplicación puede ser diferente al suyo, mi directorio se llama playground.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">npm</span> <span class=\"token function\">install</span>\n$ <span class=\"token assign-left variable\">DEBUG</span><span class=\"token operator\">=</span>playground:* <span class=\"token function\">npm</span> start\n  playground:server Listening on port <span class=\"token number\">3000</span> +0ms</code></pre></div>\n<p>Genial, ahora podemos navegar a <a href=\"http://localhost:3000\">http://localhost:3000</a> y la aplicación se está ejecutando allí.</p>\n<p>Poner la aplicación en un contenedor debería ser relativamente fácil según el ejemplo anterior.</p>\n<ul>\n<li>Usar node como base</li>\n<li>Establecer el directorio de trabajo para que no interfiramos con el contenido de la imagen base</li>\n<li>Copie TODOS los archivos en este directorio a la imagen</li>\n<li>Ejecútela con DEBUG=playground:* npm start</li>\n</ul>\n<p>Coloquemos el siguiente Dockerfile en la raíz del proyecto:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> DEBUG=playground:* npm start</span></code></pre></div>\n<p>Construyamos la imagen desde Dockerfile con un comando, <em>docker build -t express-server .</em> y ejecútelo con <em>docker run -p 3123:3000 express-server</em>. El indicador <em>-p</em> informará a Docker que se debe abrir un puerto de la máquina host y dirigirlo a un puerto en el contenedor. El formato para es <em>-p host-port:application-port</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">3123</span>:3000 express-server\n\n<span class=\"token operator\">></span> playground@0.0.0 start\n<span class=\"token operator\">></span> <span class=\"token function\">node</span> ./bin/www\n\nTue, <span class=\"token number\">29</span> Jun <span class=\"token number\">2021</span> <span class=\"token number\">10</span>:55:10 GMT playground:server Listening on port <span class=\"token number\">3000</span></code></pre></div>\n<blockquote>\n<p>Si el tuyo no funciona, pasa a la siguiente sección. Hay una explicación de por qué no puede funcionar incluso si siguió los pasos correctamente.</p>\n</blockquote>\n<p>¡La aplicación ya se está ejecutando! Probémoslo enviando una solicitud GET a <a href=\"http://localhost:3123/\">http://localhost:3123/</a>.</p>\n<p>Cerrarlo es un dolor de cabeza en este momento. Use otro terminal y el comando <em>docker kill</em> para cerrar la aplicación. El <em>docker kill</em> enviará una señal de eliminación (SIGKILL) a la aplicación para obligarla a cerrarse. Necesita el nombre o id del contenedor como argumento.</p>\n<p>Por cierto, cuando se usa id como argumento, el comienzo de la ID es suficiente para que Docker sepa a qué contenedor nos referimos.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\n  CONTAINER ID   IMAGE            COMMAND                  CREATED         STATUS         PORTS                                       NAMES\n  48096ca3ffec   express-server   <span class=\"token string\">\"docker-entrypoint.s…\"</span>   <span class=\"token number\">9</span> seconds ago   Up <span class=\"token number\">6</span> seconds   <span class=\"token number\">0.0</span>.0.0:3123-<span class=\"token operator\">></span><span class=\"token number\">3000</span>/tcp, :::3123-<span class=\"token operator\">></span><span class=\"token number\">3000</span>/tcp   infallible_booth\n\n$ <span class=\"token function\">docker</span> <span class=\"token function\">kill</span> <span class=\"token number\">48</span>\n  <span class=\"token number\">48</span></code></pre></div>\n<p>En el futuro, usemos el mismo puerto en ambos lados de <em>-p</em>. Solo para que no tengamos que recordar cuál elegimos.</p>\n<h4>Solucionar problemas potenciales que creamos al copiar y pegar</h4>\n<p>Hay algunos cambios que debemos realizar para crear un Dockerfile más completo. Incluso puede ser que el ejemplo anterior no funcione en todos los casos porque nos saltamos un paso importante.</p>\n<p>Cuando ejecutamos npm install en nuestra máquina, en algunos casos el <strong>administrador de paquetes de node (npm)</strong> puede instalar dependencias específicas del sistema operativo durante el paso de instalación. Es posible que accidentalmente movamos partes no funcionales a la imagen con la instrucción COPY. Esto puede suceder fácilmente si copiamos el directorio <i>node_modules</i> en la imagen.</p>\n<p>Esto es algo crítico a tener en cuenta cuando construimos nuestras imágenes. Es mejor hacer la mayoría de las cosas, como ejecutar <em>npm install</em> durante el proceso de compilación <i>dentro del contenedor</i> en lugar de hacerlo antes de compilar. La regla general es copiar solo los archivos que enviaría a GitHub. Los artefactos o las dependencias de compilación no se deben copiar, ya que se pueden instalar durante el proceso de compilación.</p>\n<p>Podemos usar <i>.dockerignore</i> para resolver el problema. El archivo .dockerignore es muy similar a .gitignore, puede usarlo para evitar que se copien archivos no deseados en su imagen. El archivo debe colocarse junto al Dockerfile. Aquí hay un posible contenido de un <i>.dockerignore</i></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.dockerignore\n.gitignore\nnode_modules\nDockerfile</code></pre></div>\n<p>Sin embargo, en nuestro caso, .dockerignore no es lo único que se requiere. Tendremos que instalar las dependencias durante el paso de compilación. El <em>Dockerfile</em> cambia a:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm install</span>\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> DEBUG=playground:* npm start</span></code></pre></div>\n<p>La instalación de npm puede ser riesgosa. En lugar de usar npm install, npm ofrece una herramienta mucho mejor para instalar dependencias, el comando <em>ci</em>.</p>\n<p>Diferencias entre ci e install:</p>\n<ul>\n<li>install puede actualizar el paquete-lock.json</li>\n<li>install puede instalar una versión diferente de una dependencia si tiene ^ o ~ en la versión de la dependencia.</li>\n<li>ci eliminará la carpeta node_modules antes de instalar cualquier cosa</li>\n<li>ci seguirá el paquete-lock.json y no alterará ningún archivo</li>\n</ul>\n<p>En resumen: <em>ci</em> crea compilaciones confiables, mientras que <em>install</em> es el que se usa cuando desea instalar nuevas dependencias.</p>\n<p>Como no estamos instalando nada nuevo durante el paso de compilación y no queremos que las versiones cambien repentinamente, usaremos <em>ci</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> DEBUG=playground:* npm start</span></code></pre></div>\n<p>Aún mejor, podemos usar <em>npm ci --only=production</em> para no perder tiempo instalando dependencias de desarrollo.</p>\n<blockquote>\n<p>Como notó en la lista de comparación; npm ci eliminará la carpeta node_modules, por lo que no importó crear el .dockerignore. Sin embargo, .dockerignore es una herramienta increíble cuando desea optimizar su proceso de compilación. Hablaremos brevemente sobre estas optimizaciones más adelante.</p>\n</blockquote>\n<p>Ahora el Dockerfile debería funcionar de nuevo, pruébalo con <em>docker build -t express-server . &#x26;&#x26; docker run -p 3000:3000 express-server</em></p>\n<blockquote>\n<p>Tenga en cuenta que estamos aquí encadenando dos comandos bash con &#x26;&#x26;. Podríamos obtener (casi) el mismo efecto ejecutando ambos comandos por separado. Al encadenar comandos con &#x26;&#x26;, si un comando falla, los siguientes de la cadena no se ejecutarán.</p>\n</blockquote>\n<p>Configuramos una variable de entorno <em>DEBUG=playground:*</em> durante CMD para el inicio de npm. Sin embargo, con Dockerfiles también podríamos usar la instrucción ENV para establecer variables de entorno. Vamos a hacer eso:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci </span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">ENV</span> DEBUG=playground:*</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">CMD</span> npm start</span></code></pre></div>\n<blockquote>\n<p><i>Si se pregunta qué hace la variable de entorno DEBUG, lea <a href=\"http://expressjs.com/en/guide/debugging.html#debugging-express\">aquí</a>.</i></p>\n</blockquote>\n<h4>Mejores prácticas de Dockerfile</h4>\n<p>Hay 2 reglas generales que debe seguir al crear imágenes:</p>\n<ul>\n<li>Intenta crear una imagen lo más <strong>segura</strong> posible</li>\n<li>Intenta crear una imagen lo más <strong>pequeña</strong> posible</li>\n</ul>\n<p>Las imágenes más pequeñas son más seguras al tener menos área de superficie de ataque, y las imágenes más pequeñas también se mueven más rápido en las canalizaciones de implementación.</p>\n<p>Snyk tiene una excelente lista de 10 mejores prácticas para la creación de contenedores de node/express. Léalos <a href=\"https://snyk.io/blog/10-best-practices-to-containerize-nodejs-web-applications-with-docker/\">aquí</a>.</p>\n<p>Un gran descuido que debemos resolver es ejecutar la aplicación como root en lugar de usar un usuario con menos privilegios. Hagamos una solución final al Dockerfile:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16</span>\n  \n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--chown</span><span class=\"token punctuation\">=</span><span class=\"token string\">node:node</span></span> . .</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci </span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENV</span> DEBUG=playground:*</span>\n  \n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">USER</span> node</span>\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> npm start</span></code></pre></div>\n</div>\n  \n<div class=\"tasks\">\n<h3>Ejercicio 12.5.</h3>\n<h4>Ejercicio 12.5: Contenedorización de una aplicación de Node.js</h4>\n<p>El repositorio que clonó o copió en el primer ejercicio contiene una aplicación de tareas (todo-app). Consulte todo-app/todo-backend y lea el archivo README. Todavía no tocaremos la interfaz de tareas pendientes.</p>\n<p>Paso 1. Cree un contenedor para el backend de tareas pendientes creando un <i>todo-app/todo-backend/Dockerfile</i> y construyendo una imagen.</p>\n<p>Paso 2. Ejecute la imagen de todo-backend con los puertos correctos abiertos. Asegúrese de que el contador de visitas aumente cuando se usa a través de un navegador en <a href=\"http://localhost:3000/\">http://localhost:3000/</a> (o algún otro puerto si lo configura)</p>\n<p>Sugerencia: Ejecute la aplicación fuera de un contenedor para examinarla antes de comenzar.</p>\n</div>\n  \n<div class=\"content\">\n<h3>Utilizando docker-compose</h3>\n<p>En la sección anterior, creamos express-server y sabíamos que se ejecuta en el puerto 3000, y lo ejecutamos con <em>docker build -t express-server . &#x26;&#x26; docker run -p 3000:3000 express-server</em>. Esto ya parece algo que necesitarías poner en un script para recordar. Afortunadamente, Docker nos ofrece una mejor solución.</p>\n<p><a href=\"https://docs.docker.com/compose/\">Docker-compose</a> es otra herramienta fantástica que puede ayudarnos a administrar contenedores. Comencemos a usar docker-compose a medida que aprendemos más sobre los contenedores, ya que nos ayudará a ahorrar algo de tiempo con la configuración.</p>\n<p>Instale la herramienta docker-compose desde este enlace: <a href=\"https://docs.docker.com/compose/install/\">https://docs.docker.com/compose/install/</a>.</p>\n<p>Comprobemos que funciona:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker-compose</span> <span class=\"token parameter variable\">-v</span>\n<span class=\"token function\">docker-compose</span> version <span class=\"token number\">1.29</span>.2, build 5becea4c</code></pre></div>\n<p>Y ahora podemos convertir el hechizo anterior en un archivo yaml. ¡La mejor parte de los archivos yaml es que puede guardarlos en un repositorio de Git!</p>\n<p>Cree el archivo <strong>docker-compose.yml</strong> y colóquelo en la raíz del proyecto, junto al Dockerfile. El contenido del archivo es:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3.8'</span>            <span class=\"token comment\"># Version 3.8 is quite new and should work</span>\n\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>                    <span class=\"token comment\"># The name of the service, can be anything</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> express<span class=\"token punctuation\">-</span>server <span class=\"token comment\"># Declares which image to use</span>\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span> .              <span class=\"token comment\"># Declares where to build if image is not found</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>                <span class=\"token comment\"># Declares the ports to publish</span>\n      <span class=\"token punctuation\">-</span> 3000<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span></code></pre></div>\n<p>El significado de cada línea se explica como un comentario. Si desea ver la especificación completa, consulte la [documentación] (<a href=\"https://docs.docker.com/compose/compose-file/compose-file-v3/\">https://docs.docker.com/compose/compose-file/compose-file-v3/</a>).</p>\n<p>Ahora podemos usar <em>docker-compose up</em> para compilar y ejecutar la aplicación. Si queremos reconstruir las imágenes podemos usar <em>docker-compose up --build</em>.</p>\n<p>También puede ejecutar la aplicación en segundo plano con <em>docker-compose up -d</em> (<em>-d</em> para separado) y cerrarla con <em>docker-compose down</em>.</p>\n<p>Crear archivos como este que <i>declaren</i> lo que desea en lugar de archivos de script que necesita ejecutar en un orden específico/un número específico de veces es a menudo una buena práctica.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.6.</h3>\n<h4>Ejercicio 12.6: docker-compose</h4>\n<p>Cree un archivo <i>todo-app/todo-backend/docker-compose.yml</i> que funcione con la aplicación de node del ejercicio anterior.</p>\n<p>El contador de visitas es la única característica que se requiere para estar funcionando.</p>\n</div>\n<div class=\"content\">\n<h3>Uso de contenedores en desarrollo</h3>\n<p>Cuando está desarrollando software, la contenedorización se puede utilizar de varias maneras para mejorar su calidad de vida. Uno de los casos más útiles es evitar la necesidad de instalar y configurar las herramientas dos veces.</p>\n<p>Puede que no sea la mejor opción mover todo su entorno de desarrollo a un contenedor, pero si eso es lo que desea, es posible. Retomaremos esta idea al final de esta parte. Pero hasta entonces, <i>ejecuta la propia aplicación de node fuera de los contenedores</i>.</p>\n<p>La aplicación que conocimos en los ejercicios anteriores utiliza MongoDB. Exploremos <a href=\"https://hub.docker.com/\">Docker Hub</a> para encontrar una imagen de MongoDB. Docker Hub es el lugar predeterminado desde donde Docker extrae las imágenes, también puede usar otros registros, pero dado que ya estamos metidos hasta las rodillas en Docker, es una buena opción. Con una búsqueda rápida, podemos encontrar <a href=\"https://hub.docker.com/_/mongo\">https://hub.docker.com/_/mongo</a></p>\n<p>Crea un nuevo yaml llamado <i>todo-app/todo-backend/docker-compose.dev.yml</i> que se parece a lo siguiente:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3.8'</span>\n\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database</code></pre></div>\n<p>El significado de las dos primeras variables de entorno definidas anteriormente se explica en la página de Docker Hub:</p>\n<blockquote>\n<p><i>Estas variables, usadas en conjunto, crean un nuevo usuario y establecen la contraseña de ese usuario. Este usuario se crea en la base de datos de autenticación del administrador y se le otorga el rol de root (\"superusuario\").</i></p>\n</blockquote>\n<p>La última variable de entorno <em>MONGO_INITDB_DATABASE</em> le indicará a MongoDB que cree una base de datos con ese nombre.</p>\n<p>Puede usar el indicador <em>-f</em> para especificar un <i>archivo</i> para ejecutar el comando Docker Compose con, p. <em>docker-compose -f docker-compose.dev.yml up</em>. Ahora que podemos tener múltiples, es útil.</p>\n<p>Ahora inicie MongoDB con <em>docker-compose -f docker-compose.dev.yml up -d</em>. Con <em>-d</em> lo ejecutará en segundo plano. Puede ver los registros de salida con <em>docker-compose -f docker-compose.dev.yml logs -f</em>. Allí, <em>-f</em> se asegurará de que <i>seguimos</i> los registros.</p>\n<p>Como se dijo anteriormente, actualmente <strong>no</strong> queremos ejecutar la aplicación Node dentro de un contenedor. Desarrollar mientras la aplicación en sí está dentro de un contenedor es un desafío. Exploraremos esa opción más adelante en esta parte.</p>\n<p>Ejecute el viejo <em>npm install</em> primero en su máquina para configurar la aplicación Node. Luego inicie la aplicación con la variable de entorno relevante. Puede modificar el código para configurarlos como predeterminados o usar el archivo .env. No pasa nada por poner estas claves en GitHub, ya que solo se usan en su entorno de desarrollo local. Los agregaré con <em>npm run dev</em> para ayudarlo a copiar y pegar.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">MONGO_URL</span><span class=\"token operator\">=</span>mongodb://localhost:3456/the_database <span class=\"token function\">npm</span> run dev</code></pre></div>\n<p>Esto no será suficiente; necesitamos crear un usuario para ser autorizado dentro del contenedor. La url <a href=\"http://localhost:3000/todos\">http://localhost:3000/todos</a> genera un error de autenticación:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> <span class=\"token number\">2.0</span>.12\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> to restart at any time, enter <span class=\"token variable\"><span class=\"token variable\">`</span>rs<span class=\"token variable\">`</span></span>\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> watching path<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>: *.*\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> watching extensions: js,mjs,json\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> starting <span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">node</span> ./bin/www<span class=\"token variable\">`</span></span>\n<span class=\"token punctuation\">(</span>node:37616<span class=\"token punctuation\">)</span> UnhandledPromiseRejectionWarning: MongoError: <span class=\"token builtin class-name\">command</span> <span class=\"token function\">find</span> requires authentication\n    at MessageStream.messageHandler <span class=\"token punctuation\">(</span>/Users/mluukkai/opetus/docker-fs/container-app/express-app/node_modules/mongodb/lib/cmap/connection.js:272:20<span class=\"token punctuation\">)</span>\n    at MessageStream.emit <span class=\"token punctuation\">(</span>events.js:314:20<span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Vincular e inicializar la base de datos</h3>\n<p>En la página <a href=\"https://hub.docker.com/_/mongo\">MongoDB Docker Hub</a> en la sección \"Inicializar una nueva instancia\" se encuentra la información sobre cómo ejecutar JavaScript para inicializar la base de datos y un usuario para ella.</p>\n<p>El proyecto de ejercicio tiene un archivo <i>todo-app/todo-backend/mongo/mongo-init.js</i> con el contenido:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">db<span class=\"token punctuation\">.</span><span class=\"token function\">createUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">user</span><span class=\"token operator\">:</span> <span class=\"token string\">'the_username'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">pwd</span><span class=\"token operator\">:</span> <span class=\"token string\">'the_password'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">roles</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      <span class=\"token literal-property property\">role</span><span class=\"token operator\">:</span> <span class=\"token string\">'dbOwner'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token literal-property property\">db</span><span class=\"token operator\">:</span> <span class=\"token string\">'the_database'</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndb<span class=\"token punctuation\">.</span><span class=\"token function\">createCollection</span><span class=\"token punctuation\">(</span><span class=\"token string\">'todos'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\ndb<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">text</span><span class=\"token operator\">:</span> <span class=\"token string\">'Write code'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">done</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndb<span class=\"token punctuation\">.</span>todos<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">text</span><span class=\"token operator\">:</span> <span class=\"token string\">'Learn about containers'</span><span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">done</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Este archivo inicializará la base de datos con un usuario y algunas tareas. A continuación, debemos colocarlo dentro del contenedor al inicio.</p>\n<p>Podríamos crear una nueva imagen DESDE mongo y COPIAR el archivo, o podemos usar un <i>bind mount</i> para montar el archivo <i>mongo-init.js</i> en el contenedor. Hagamos esto último.</p>\n<p>Bind mount es el acto de vincular un archivo en la máquina host a un archivo en el contenedor. Podríamos agregar un indicador <em>-v</em> con <em>container run</em>. La sintaxis es <em>-v ARCHIVO-EN-HOST:ARCHIVO-EN-CONTENEDOR</em>. Como ya aprendimos sobre Docker Compose, omitámoslo. El montaje de enlace se declara bajo la clave <i>volumes</i> en docker-compose. De lo contrario, el formato es el mismo, primero host y luego contenedor:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span> </span><span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> ./mongo/mongo<span class=\"token punctuation\">-</span>init.js<span class=\"token punctuation\">:</span>/docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d/mongo<span class=\"token punctuation\">-</span>init.js</span></code></pre></div>\n<p>El resultado del vínculo es que el archivo <i>mongo-init.js</i> en la carpeta mongo de la máquina host es el mismo que el archivo <i>mongo-init.js</i> en el directorio /docker-entrypoint-initdb.d del contenedor. Los cambios en cualquiera de los archivos estarán disponibles en el otro. No necesitamos hacer ningún cambio durante el tiempo de ejecución. Pero esta será la clave para el desarrollo de software en contenedores.</p>\n<p>Ejecute <em>docker-compose -f docker-compose.dev.yml down --volumes</em> para asegurarse de que no quede nada y comience desde cero con <em>docker-compose -f docker-compose.dev.yml up</em> para inicializar la base de datos.</p>\n<p>Si ve un error como este:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">mongo_database <span class=\"token operator\">|</span> failed to load: /docker-entrypoint-initdb.d/mongo-init.js\nmongo_database <span class=\"token operator\">|</span> exiting with code <span class=\"token parameter variable\">-3</span></code></pre></div>\n<p>es posible que tenga un problema de permiso de lectura. No son raros cuando se trata de volúmenes. En el caso anterior, puede usar <em>chmod a+r mongo-init.js</em>, que les dará a todos acceso de lectura a ese archivo. Tenga cuidado al usar <em>chmod</em> ya que otorgar más privilegios puede ser un problema de seguridad. Use <em>chmod</em> solo en mongo-init.js en su computadora.</p>\n<p>Ahora, iniciar la aplicación express con la variable de entorno correcta debería funcionar:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">MONGO_URL</span><span class=\"token operator\">=</span>mongodb://the_username:the_password@localhost:3456/the_database <span class=\"token function\">npm</span> run dev</code></pre></div>\n<p>Verifiquemos que <a href=\"http://localhost:3000/todos\">http://localhost:3000/todos</a> devuelve las tareas. Debería devolver las dos tareas que inicializamos. Podemos y debemos usar Postman para probar la funcionalidad básica de la aplicación, como agregar o eliminar una tarea.</p>\n<h3>Persistir datos con volúmenes</h3>\n<p>Por defecto, los contenedores no conservarán nuestros datos. Cuando cierre el contenedor de mongo, es posible que no pueda recuperar los datos.</p>\n<p>Este es un caso raro en el que conserva los datos, ya que los desarrolladores que crearon la imagen de Docker para Mongo han definido un volumen para usar: <a href=\"https://github.com/docker-library/mongo/blob/cb8a419053858e510fc68ed2d69415b3e50011cb/4.4/Dockerfile#L113\">https://github.com/docker-library/mongo/blob/cb8a419053858e510fc68ed2d69415b3e50011cb/4.4 /Dockerfile#L113</a> Esta línea indicará a Docker que conserve los datos en esos directorios.</p>\n<p>Hay dos métodos distintos para almacenar los datos:</p>\n<ul>\n<li>Declarar una ubicación en su sistema de archivos (llamado montaje de enlace (bind mount) )</li>\n<li>Dejar que Docker decida dónde almacenar los datos (volumen)</li>\n</ul>\n<p>Prefiero la primera opción en la mayoría de los casos siempre que <i>realmente</i> necesite evitar eliminar los datos. Veamos ambos en acción con docker-compose:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./mongo/mongo<span class=\"token punctuation\">-</span>init.js<span class=\"token punctuation\">:</span>/docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d/mongo<span class=\"token punctuation\">-</span>init.js\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> ./mongo_data<span class=\"token punctuation\">:</span>/data/db</span></code></pre></div>\n<p>Lo anterior creará un directorio llamado <em>mongo_data</em> en su sistema de archivos local y lo asignará al contenedor como <em>/data/db</em>. Esto significa que los datos en <em>/data/db</em> se almacenan fuera del contenedor, ¡pero el contenedor aún puede acceder a ellos! Solo recuerda agregar el directorio a .gitignore.</p>\n<p>Se puede lograr un resultado similar con un volumen con nombre:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mongo\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> 3456<span class=\"token punctuation\">:</span><span class=\"token number\">27017</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_USERNAME</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">MONGO_INITDB_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span> example\n      <span class=\"token key atrule\">MONGO_INITDB_DATABASE</span><span class=\"token punctuation\">:</span> the_database\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./mongo/mongo<span class=\"token punctuation\">-</span>init.js<span class=\"token punctuation\">:</span>/docker<span class=\"token punctuation\">-</span>entrypoint<span class=\"token punctuation\">-</span>initdb.d/mongo<span class=\"token punctuation\">-</span>init.js\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> mongo_data<span class=\"token punctuation\">:</span>/data/db</span>\n<span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n  mongo_data<span class=\"token punctuation\">:</span></code></pre></div>\n<p>Ahora, Docker crea y administra el volumen. Después de iniciar la aplicación (<em>docker-compose -f docker-compose.dev.yml up</em>) puede enumerar los volúmenes con <em>docker volume ls</em>, inspeccionar uno de ellos con <em>docker volume inspect</em> e incluso eliminarlos con <em>docker volume rm</em>. Todavía está almacenado en su sistema de archivos local, pero descubrir <i>dónde</i> puede no ser tan trivial como con la opción anterior.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.7.</h3>\n<h4>Ejercicio 12.7: Un poco de codificación MongoDB</h4>\n<p>Tenga en cuenta que este ejercicio asume que ha realizado todas las configuraciones realizadas en material después del ejercicio 12.5. Aún debe ejecutar el backend de la aplicación de tareas pendientes <i>fuera de un contenedor</i>, solo MongoDB está en un contenedor por ahora.</p>\n<p>La aplicación de tareas pendientes no tiene una implementación adecuada de las rutas para obtener una tarea pendiente (GET <i>/todos/:id</i>) y actualizar una tarea pendiente (PUT <i>/todos/:id</i>). Arregle el código.</p>\n</div>\n<div class=\"content\">\n<h3>Depuración en contenedores</h3>\n<blockquote>\n<p><i>Cuando codificas, lo más probable es que termines en una situación en la que todo está roto.</i></p>\n</blockquote>\n<blockquote>\n<p>- Matti Luukkainen</p>\n</blockquote>\n<p>Al desarrollar con contenedores, necesitamos aprender nuevas herramientas para la depuración, ya que no podemos simplemente usar \"console.log\" para todo. Cuando el código tiene un error, a menudo puede estar en un estado en el que al menos algo funciona y podemos avanzar a partir de ahí. La configuración suele estar en cualquiera de los dos estados: 1. funcionando o 2. rota. Repasaremos algunas herramientas que pueden ayudar cuando su aplicación se encuentra en este último estado.</p>\n<p>Al desarrollar software, puede avanzar paso a paso con seguridad, verificando todo el tiempo que lo que ha codificado se comporta como se espera. A menudo, este no es el caso cuando se realizan configuraciones. La configuración que puede estar escribiendo puede romperse hasta en el momento en que finaliza. Entonces, cuando escribe un docker-compose.yml o Dockerfile largo y no funciona, debe tomarse un momento y pensar en las diversas formas en que podría confirmar que algo funciona.</p>\n<p><i>Cuestionar todo</i> sigue siendo aplicable aquí. Como se dijo en la <a href=\"/en/part3/saving_data_to_mongo_db\">parte 3</a>: La clave es ser sistemático. Dado que el problema puede existir en cualquier lugar, <i>debe cuestionar todo</i> y eliminar todas las posibles fuentes de error una por una.</p>\n<p>Para mí, el método más valioso de depuración es detenerme y pensar en lo que estoy tratando de lograr en lugar de simplemente golpearme la cabeza con el problema. A menudo hay una solución simple, alternativa, o una búsqueda rápida en Google que me ayudará a seguir adelante.</p>\n<h4>exec</h4>\n<p>El comando Docker <a href=\"https://docs.docker.com/engine/reference/commandline/exec/\">exec</a> es un gran bateador. Se puede usar para saltar directamente a un contenedor cuando se está ejecutando.</p>\n<p>Iniciemos un servidor web en segundo plano y hagamos un poco de depuración para que funcione y muestre el mensaje \"¡Hola, exec!\" en nuestro navegador. Elijamos <a href=\"https://www.nginx.com/\">Nginx</a> que es, entre otras cosas, un servidor capaz de servir archivos HTML estáticos. Tiene un index.html predeterminado que podemos reemplazar.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">-d</span> nginx</code></pre></div>\n<p>Bien, ahora las preguntas son:</p>\n<ul>\n<li>¿Dónde debemos ir con nuestro navegador?</li>\n<li>¿Está incluso funcionando?</li>\n</ul>\n<p>Sabemos cómo responder a lo último: enumerando los contenedores en ejecución.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE           COMMAND                  CREATED              STATUS                      PORTS     NAMES\n3f831a57b7cc   nginx           <span class=\"token string\">\"/docker-entrypoint.…\"</span>   About a minute ago   Up About a minute           <span class=\"token number\">80</span>/tcp    keen_darwin</code></pre></div>\n<p>¡Sí! También hemos respondido a la primera pregunta. Parece escuchar en el puerto 80, como se ve en la salida anterior.</p>\n<p>Apaguémoslo y reiniciemos con el indicador <em>-p</em> para que nuestro navegador acceda a él.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container stop keen_darwin\n$ <span class=\"token function\">docker</span> container <span class=\"token function\">rm</span> keen_darwin\n\n$ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">-d</span> <span class=\"token parameter variable\">-p</span> <span class=\"token number\">8080</span>:80 nginx</code></pre></div>\n<p>Miremos la aplicación en <a href=\"http://localhost:8080\">http://localhost:8080</a>. ¡Parece que la aplicación muestra un mensaje incorrecto! Saltemos directamente al contenedor y arreglémoslo. Mantenga su navegador abierto, no necesitaremos cerrar el contenedor para esta corrección. Ejecutaremos bash dentro del contenedor, las banderas <em>-it</em> asegurarán que podamos interactuar con el contenedor:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS                                   NAMES\n7edcb36aff08   nginx     <span class=\"token string\">\"/docker-entrypoint.…\"</span>   About a minute ago   Up About a minute   <span class=\"token number\">0.0</span>.0.0:8080-<span class=\"token operator\">></span><span class=\"token number\">80</span>/tcp, :::8080-<span class=\"token operator\">></span><span class=\"token number\">80</span>/tcp   wonderful_ramanujan\n\n$ <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> wonderful_ramanujan <span class=\"token function\">bash</span>\nroot@7edcb36aff08:/<span class=\"token comment\">#</span></code></pre></div>\n<p>Ahora que estamos dentro, necesitamos encontrar el archivo defectuoso y reemplazarlo. Rapidamente Google nos dice que el archivo en sí es <em>/usr/share/nginx/html/index.html</em>.</p>\n<p>Pasemos al directorio y eliminemos el archivo.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@7edcb36aff08:/<span class=\"token comment\"># cd /usr/share/nginx/html/</span>\nroot@7edcb36aff08:/<span class=\"token comment\"># rm index.html</span></code></pre></div>\n<p>Ahora, si vamos a <a href=\"http://localhost:8080/\">http://localhost:8080/</a> sabemos que eliminamos el archivo correcto. La página muestra 404. Vamos a reemplazarlo con uno que contenga el contenido correcto:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@7edcb36aff08:/<span class=\"token comment\"># echo \"Hello, exec!\" > index.html</span></code></pre></div>\n<p>¡Actualice la página y se mostrará nuestro mensaje! Ahora sabemos cómo se puede usar exec para interactuar con los contenedores. Recuerde que todos los cambios se pierden cuando se elimina el contenedor. Para conservar los cambios, debe usar <em>commit</em> tal como lo hicimos en la <a href=\"/es/part12/introduccion_a_los_contenedores#otros-comandos-de-docker\">sección anterior</a>.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.8.</h3>\n<h4>Ejercicio 12.8: Interfaz de linea de comandos (CLI) de Mongo</h4>\n<blockquote>\n<p>Use <em>script</em> para registrar lo que hace, guarde el archivo en script-answers/exercise12_8.txt</p>\n</blockquote>\n<p>Mientras se ejecuta MongoDB del ejercicio anterior, acceda a la base de datos con la interfaz de línea de comandos (CLI) de mongo. Puedes hacerlo usando docker exec. A continuación, agregue una tarea nueva mediante la CLI.</p>\n<p>El comando para abrir CLI cuando está dentro del contenedor es <em>mongo</em></p>\n<p>La CLI de mongo requerirá las marcas de nombre de usuario y contraseña para autenticarse correctamente. Las banderas <em>-u root -p example</em> deberían funcionar, los valores corresponden a los que se encuentran en el archivo docker-compose.dev.yml.</p>\n<ul>\n<li>Paso 1: Ejecute MongoDB</li>\n<li>Paso 2: use docker exec para ingresar al contenedor</li>\n<li>Paso 3: Abrir mongo cli</li>\n</ul>\n<p>Cuando se haya conectado a Mongo cli, puede pedirle que muestre dbs dentro:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> show dbs\nadmin         <span class=\"token number\">0</span>.000GB\nconfig         <span class=\"token number\">0</span>.000GB\n<span class=\"token builtin class-name\">local</span>         <span class=\"token number\">0</span>.000GB\nthe_database  <span class=\"token number\">0</span>.000GB</code></pre></div>\n<p>Para acceder a la base de datos correcta:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> use the_database</code></pre></div>\n<p>Y finalmente para conocer las colecciones:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> show collections\ntodos</code></pre></div>\n<p>Ahora podemos acceder a los datos en esas colecciones:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token operator\">></span> db.todos.find<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span> <span class=\"token string\">\"_id\"</span> <span class=\"token builtin class-name\">:</span> ObjectId<span class=\"token punctuation\">(</span><span class=\"token string\">\"611e54b688ddbb7e84d3c46b\"</span><span class=\"token punctuation\">)</span>, <span class=\"token string\">\"text\"</span> <span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"Write code\"</span>, <span class=\"token string\">\"done\"</span> <span class=\"token builtin class-name\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span> <span class=\"token string\">\"_id\"</span> <span class=\"token builtin class-name\">:</span> ObjectId<span class=\"token punctuation\">(</span><span class=\"token string\">\"611e54b688ddbb7e84d3c46c\"</span><span class=\"token punctuation\">)</span>, <span class=\"token string\">\"text\"</span> <span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"Learn about containers\"</span>, <span class=\"token string\">\"done\"</span> <span class=\"token builtin class-name\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Inserte una tarea pendiente nueva con el texto: \"Increase the number of tools in my toolbelt\" con el estado hecho como falso. Consulte la <a href=\"https://docs.mongodb.com/v4.4/reference/method/db.collection.insertOne/#mongodb-method-db.collection.insertOne\">documentación</a> para ver cómo se realiza la adición.</p>\n<p>Asegúrese de ver la nueva tarea tanto en la aplicación Express como al consultar desde la CLI de Mongo.</p>\n</div>\n<div class=\"content\">\n<h3>Redis</h3>\n<p><a href=\"https://redis.io/\">Redis</a> es una base de datos <a href=\"https://redis.com/nosql/key-value-databases/\">clave-valor</a>. En contraste con por ej. MongoDB, los datos almacenados en un almacenamiento de clave-valor tienen un poco menos de estructura, por ejemplo no contiene colecciones ni tablas, solo contiene pedazos de datos que se pueden obtener en función de la <i>clave</i> que se adjuntó a los datos (el <i>valor</i>).</p>\n<p>De forma predeterminada, Redis funciona <i>en memoria</i>, lo que significa que no almacena datos de forma persistente.</p>\n<p>Un caso de uso excelente para Redis es usarlo como <i>caché</i>. Los cachés a menudo se usan para almacenar datos que, de otro modo, serían lentos para obtener y guardar los datos hasta que ya no sean válidos. Después de que la memoria caché se vuelva inválida, recuperará los datos nuevamente y los almacenará en la memoria caché.</p>\n<p>Redis no tiene nada que ver con los contenedores. Pero dado que ya podemos agregar <i>cualquier</i> servicio de terceros a sus aplicaciones, ¿por qué no conocer uno nuevo?</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicios 12.9. - 12.11.</h3>\n<h4>Ejercicio 12.9: Instalando Redis en el proyecto</h4>\n<p>El servidor Express ya se configuró para usar Redis y solo falta la variable de entorno <em>REDIS_URL</em>. La aplicación utilizará esa variable de entorno para conectarse a Redis. Lea la <a href=\"https://hub.docker.com/_/redis\">página de Docker Hub para Redis</a>, agregue Redis a <i>todo-app/todo-backend/docker-compose.dev.yml&#x3C;/ i> definiendo otro servicio después de mongo:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">mongo</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">...</span>\n  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">?</span><span class=\"token punctuation\">?</span><span class=\"token punctuation\">?</span></code></pre></div>\n<p>Dado que la página de Docker Hub no tiene toda la información, podemos usar Google para ayudarnos. El puerto predeterminado para Redis se encuentra facilmente al buscarlo:</p>\n<picture><img src=\"/static/c2052870c4d9cd9369bf0f66dd1b1cf9/5a190/redis_port_by_google.png\" srcset=\"/static/c2052870c4d9cd9369bf0f66dd1b1cf9/772e8/redis_port_by_google.png 200w,\n/static/c2052870c4d9cd9369bf0f66dd1b1cf9/e17e5/redis_port_by_google.png 400w,\n/static/c2052870c4d9cd9369bf0f66dd1b1cf9/5a190/redis_port_by_google.png 800w,\n/static/c2052870c4d9cd9369bf0f66dd1b1cf9/f96df/redis_port_by_google.png 849w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>No sabremos si la configuración funciona a menos que la probemos. La aplicación no comenzará a usar Redis por sí sola, eso sucederá en el próximo ejercicio.</p>\n<p>Una vez que Redis esté configurado e iniciado, reinicie el backend y asígnele el <i>REDIS_URL</i>, que tiene la forma <i>redis://host:port</i></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token assign-left variable\">REDIS_URL</span><span class=\"token operator\">=</span>insert-redis-url-here <span class=\"token assign-left variable\">MONGO_URL</span><span class=\"token operator\">=</span>mongodb://localhost:3456/the_database <span class=\"token function\">npm</span> run dev</code></pre></div>\n<p>Ahora puede probar la configuración agregando la línea</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> redis <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'../redis'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>al servidor Express, por ejemplo. en el archivo <i>routes/index.js</i>. Si no pasa nada, la configuración se hizo correctamente. Si no, el servidor falla:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">events.js:291\n      throw er<span class=\"token punctuation\">;</span> // Unhandled <span class=\"token string\">'error'</span> event\n      ^\n\nError: Redis connection to localhost:637 failed - connect ECONNREFUSED <span class=\"token number\">127.0</span>.0.1:6379\n    at TCPConnectWrap.afterConnect <span class=\"token punctuation\">[</span>as oncomplete<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span>net.js:1144:16<span class=\"token punctuation\">)</span>\nEmitted <span class=\"token string\">'error'</span> event on RedisClient instance at:\n    at RedisClient.on_error <span class=\"token punctuation\">(</span>/Users/mluukkai/opetus/docker-fs/container-app/express-app/node_modules/redis/index.js:342:14<span class=\"token punctuation\">)</span>\n    at Socket.<span class=\"token operator\">&lt;</span>anonymous<span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>/Users/mluukkai/opetus/docker-fs/container-app/express-app/node_modules/redis/index.js:223:14<span class=\"token punctuation\">)</span>\n    at Socket.emit <span class=\"token punctuation\">(</span>events.js:314:20<span class=\"token punctuation\">)</span>\n    at emitErrorNT <span class=\"token punctuation\">(</span>internal/streams/destroy.js:100:8<span class=\"token punctuation\">)</span>\n    at emitErrorCloseNT <span class=\"token punctuation\">(</span>internal/streams/destroy.js:68:3<span class=\"token punctuation\">)</span>\n    at processTicksAndRejections <span class=\"token punctuation\">(</span>internal/process/task_queues.js:80:21<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  errno: -61,\n  code: <span class=\"token string\">'ECONNREFUSED'</span>,\n  syscall: <span class=\"token string\">'connect'</span>,\n  address: <span class=\"token string\">'127.0.0.1'</span>,\n  port: <span class=\"token number\">6379</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">[</span>nodemon<span class=\"token punctuation\">]</span> app crashed - waiting <span class=\"token keyword\">for</span> <span class=\"token function\">file</span> changes before starting<span class=\"token punctuation\">..</span>.</code></pre></div>\n<h4>Ejercicio 12.10:</h4>\n<p>El proyecto ya tiene <a href=\"https://www.npmjs.com/package/redis\">https://www.npmjs.com/package/redis</a> instalado y dos funciones \"prometidas\": getAsync y setAsync.</p>\n<ul>\n<li>La función setAsync toma la clave y el valor, usando la clave para almacenar el valor.</li>\n<li>La función getAsync toma la clave y devuelve el valor en una promesa.</li>\n</ul>\n<p>Implemente un contador de tareas pendientes que guarde la cantidad de tareas pendientes creadas en Redis:</p>\n<ul>\n<li>Paso 1: cada vez que se envíe una solicitud para agregar una tarea pendiente, incremente el contador en uno.</li>\n<li>Paso 2: Cree un punto final GET/statistics donde pueda solicitar los metadatos de uso. El formato debe ser el siguiente JSON:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"added_todos\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>Ejercicio 12.11:</h4>\n<blockquote>\n<p>Use <em>script</em> para registrar lo que hace, guarde el archivo como script-answers/exercise12_11.txt</p>\n</blockquote>\n<p>Si la aplicación no se comporta como se esperaba, un acceso directo a la base de datos puede ser beneficioso para identificar problemas. Probemos cómo se puede usar <a href=\"https://redis.io/topics/rediscli\">redis-cli</a> para acceder a la base de datos.</p>\n<ul>\n<li>Vaya al contenedor de redis con <em>docker exec</em> y abra el archivo redis-cli.</li>\n<li>Encuentra la clave que usaste con <em><a href=\"https://redis.io/commands/keys\">KEYS *</a></em></li>\n<li>Verifique el valor de la clave con el comando <a href=\"https://redis.io/commands/get\">GET</a></li>\n<li>Establezca el valor del contador en 9001, encuentre el comando correcto desde <a href=\"https://redis.io/commands/\">aquí</a></li>\n<li>Asegúrese de que el nuevo valor funcione actualizando la página <a href=\"http://localhost:3000/statistics\">http://localhost:3000/statistics</a></li>\n<li>Cree una nueva tarea con Postman y asegúrese de que el contador haya aumentado en consecuencia desde redis-cli</li>\n<li>Elimine la clave de cli y asegúrese de que el contador funcione cuando se agreguen nuevas tareas</li>\n</ul>\n</div>\n<div class=\"content\">\n<h3>Persistiendo datos con Redis</h3>\n<p>En la sección anterior, se mencionó que <i>por defecto</i> Redis no conserva los datos. Sin embargo, la persistencia es fácil de activar. Solo necesitamos iniciar Redis con un comando diferente, como se indica en la <a href=\"https://hub.docker.com/_/redis\">página del centro de Docker</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># Everything else</span>\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'redis-server'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'--appendonly'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'yes'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># Overwrite the CMD</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># Declare the volume</span>\n      <span class=\"token punctuation\">-</span> ./redis_data<span class=\"token punctuation\">:</span>/data</code></pre></div>\n<p>Los datos ahora se almacenarán en el directorio <i>redis_data</i> de la máquina host.\n¡Recuerde agregar el directorio a .gitignore!</p>\n<h4>Otras funcionalidades de Redis</h4>\n<p>Además de las operaciones GET, SET y DEL en claves y valores, Redis también puede hacer mucho más. Por ejemplo, puede hacer que las claves caduquen automáticamente, lo que es una característica muy útil cuando Redis se usa como caché.</p>\n<p>Redis también se puede utilizar para implementar el patrón denominado <a href=\"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern\">publish-subscribe</a> (o PubSub), que es un mecanismo de comunicación asincrónica para aplicaciones distribuidas. En este escenario, Redis funciona como un <i>agente de mensajes</i> entre dos o más aplicaciones. Algunas de las aplicaciones están <i>publicando</i> mensajes enviándolos a Redis, que al recibir un mensaje, informa a las partes que se han <i>suscrito</i> a esos mensajes.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.12.</h3>\n<h4>Ejercicio 12.12: Persistiendo datos en Redis</h4>\n<p>Compruebe que los datos no se conservan de forma predeterminada: después de ejecutar <em>docker-compose -f docker-compose.dev.yml down</em> y <em>docker-compose -f docker-compose.dev.yml up</em> el valor del contador se restablece a 0.</p>\n<p>Luego, cree un volumen para los datos de Redis (modificando <i>todo-app/todo-backend/docker-compose.dev.yml </i>) y asegúrese de que los datos sobrevivan después de ejecutar <em>docker-compose -f docker-compose .dev.yml down</em> y <em>docker-compose -f docker-compose.dev.yml up</em>.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/09ec6709015c0dcb492111bd9e645d3d/part-12.svg"},"part":12,"letter":"b","lang":"es"}}},"pageContext":{"part":12,"letter":"b","lang":"es"}},"staticQueryHashes":["3128451518"]}