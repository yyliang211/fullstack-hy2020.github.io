{"componentChunkName":"component---src-templates-content-template-js","path":"/es/part12/introduccion_a_los_contenedores","result":{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<p>El desarrollo de software incluye un amplio ciclo, desde el imaginado software hasta la programación y la liberación al usuario final e incluso su mantenimiento. Esta parte será una introducción a los contenedores, una herramienta moderna utilizada en las partes finales del ciclo de desarrollo de software.</p>\n<p>Los contenedores encapsulan tu aplicación en un solo paquete. Este paquete entonces incluirá todas las dependencias con la aplicación. Como resultado cada contenedor puede correr aislado de otros contenedores.</p>\n<p>Los contenedores previenen que la aplicación pueda acceder a los archivos y recursos del dispositivo. Los desarrolladores pueden establecer permisos a las aplicaciones para que accedan a los archivos y también especificar recursos disponibles. Más preciso, los contenedores son virtualizaciones a nivels de Sistema Operativo ( OS-level virtualization ). La comparación más cercana es con una máquina virtual (VM). VMs son utilizadas para correr múltiples sistemas operativos en una misma máquina física. Ellas tienen que ejecutar todo el sistema operativo, mientras que los contenedores ejecutan el software utilizando el sistema operativo del host. La diferencia resultante entre las máquinas virtuales y los contenedores es que apenas hay gastos generales cuando se ejecutan contenedores; solo necesitan ejecutar un solo proceso.</p>\n<p>Como los contenedores son relativamente ligeros, al menos comparados con las máquinas virtuales, estos pueden ser escalados con rápidez. Y como aislan el software que ejecutan dentro, permiten que el software se ejecute de manera idéntica en cualquier ambiente. Por ello, son la opción preferida en cualquier entorno basado en la nube o aplicación con más de un puñado de usuarios.</p>\n<p>Servicios como AWS, Google Cloudy Microsoft Azure soportan contenedores en diferentes formas. Estos incluyen a AWS Fargate y Google Cloud Run, ambos permiten ejecutar los contenedores sin servidor (serverless) - donde el contenedor de la aplicación ni siquiera necesita estar ejecutándose si no es utilizado. También puedes instalar un entorno de ejecución de contenedores en la mayoría de las computadoros y correrlos tú mismo- incluyendo tu propia máquina.</p>\n<p>Por lo que los contenedores son utilizados en ambientes en la nube e incluso durante el desarrollo. Cuáles son los beneficios de utilizar contenedores? He aquí dos escenarios comunes:</p>\n<p><i>Escenario 1: Estás desarrollando una aplicación nueva que necesita ejecutarse en la misma máquina que una aplicación antigua (legacy). Ambas requieren diferentes versiones de Node instalada.</i></p>\n<p>Tú probablemente utilices nvm, máquinas virtuales o magia negra para lograr ejecutarlas al mismo tiempo. Sin embargo los contenedores son una excelente solución ya que puedes ejecutar ambas aplicaciones en sus respectivos contenedores. Ellas están aisladas una de otra y no interfieren.</p>\n<p><i>Escenario 2: Tu aplicación se ejecuta en tu ordenador. Necesitas mover la aplicación a un servidor</i></p>\n<p>No es poco común que la aplicación simplemente no se ejecute en el servidor a pesar de estar trabajando bien en tu computadora. Esto puede ocurrir debido a algunas dependencias faltantes o otras diferencias en los entornos. Aquí los contenedores son una excelente solución ya que puedes ejecutar tu aplicación en el mismo ambiente tanto en tu computadora como en el servidor. No es perfecto: las diferencias en el hardware pueden provocar incidentes, pero puedes limitar estas diferencias entre los ambientes.</p>\n<p>Alguna vez podrás escuchar sobre el tema <i>\"Works in my container\"</i>. La frase describe la situación en la que la aplicación funciona bien en un contenedor ejecutándose en tu computadora pero se rompe cuando el contenedor es iniciado en el servidor. Esta frase es una variante del infame tema <i>\"Works on my machine\"</i>, que con frecuencia resuelven los contenedores. La situación es también con mucha certeza un error de uso.</p>\n<h3>Sobre esta parte</h3>\n<p>En esta parte, el foco de nuestra atención no estará en el código JavaScript. En cambio, nos interesa la configuración del entorno en el que se ejecuta el software. Como resultado, es posible que los ejercicios no contengan ningún código, las aplicaciones están disponibles para usted a través de GitHub y sus tareas incluirán configurarlas. Los ejercicios deben enviarse a <i>un solo repositorio de GitHub</i> que incluirá todo el código fuente y la configuración que realice durante esta parte.</p>\n<p>Necesitará conocimientos básicos de Node, Express y React. Solo las partes principales, 1 a 5, deben ser completadas antes de esta parte.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.1</h3>\n<h3><i>Advertencia</i></h3>\n<p>Dado que estamos saliendo de nuestra zona de confort como desarrolladores de JavaScript, esta parte puede requerir que tome un desvío y se familiarice con shell/ línea de comandos/ símbolo del sistema/ terminal antes de comenzar.</p>\n<p>Si solo ha utilizado una interfaz gráfica de usuario y nunca ha tocado, p. Linux o terminal en Mac, o si te quedas atascado en los primeros ejercicios, te recomendamos hacer primero la Parte 1 de \"Herramientas informáticas para estudios de CS\": <a href=\"https://tkt-lapio.github.io/en/\">https://tkt-lapio.github.io/en/</a>. Omita la sección \"Conexión SSH\" y el Ejercicio 11. ¡Esto incluye todo lo que necesitará para comenzar aquí!</p>\n<h4>Ejercicio 12.1: Usando una computadora (sin la interfaz gráfica de usuario)</h4>\n<p>Paso 1: Lee el texto debajo de la cabecera Advertencia.</p>\n<p>Paso 2: Descargue este <a href=\"https://github.com/fullstack-hy2020/part12-containers-applications\">repositorio</a> y conviértelo en tu repositorio de envío de esta parte del curso.</p>\n<p>Paso 3: Ejecuta <i>curl <a href=\"http://helsinki.fi\">http://helsinki.fi</a></i> y guarda el resultado en un archivo. Guarda el archivo en tu repositorio con el nombre <i>script-answers/exercise12_1.txt</i>. El directorio <i>script-answers</i> ha sido creado en el paso anterior.</p>\n</div>\n<div class=\"content\">\n<h3>Enviar los ejercicios y recibir los créditos</h3>\n<p>Envía los ejercicios utilizando el <a href=\"https://studies.cs.helsinki.fi/stats/\">sistema de envío</a> igual que en las partes anteriores. Los ejercicios de esta parte son enviados <i>a su <a href=\"https://studies.cs.helsinki.fi/stats/courses/fs-containers\">propia instancia</a></i>.</p>\n<p>Completar esta parte supondrá la obtención de 1 crédito. Note que debe realizar todos los ejercicios para obtener el crédito o el certificado.</p>\n<p>Una vez completado los ejercicios y desee obtener los créditos, déjanos saber a través del sistema de envío de ejercicios que has completado el curso::</p>\n<picture><img src=\"/static/ba7a651de70d2d2e13697df135255a90/5a190/23.png\" alt=\"Enviar los ejercicios para obtener los créditos\" srcset=\"/static/ba7a651de70d2d2e13697df135255a90/772e8/23.png 200w,\n/static/ba7a651de70d2d2e13697df135255a90/e17e5/23.png 400w,\n/static/ba7a651de70d2d2e13697df135255a90/5a190/23.png 800w,\n/static/ba7a651de70d2d2e13697df135255a90/c1b63/23.png 1200w,\n/static/ba7a651de70d2d2e13697df135255a90/29007/23.png 1600w,\n/static/ba7a651de70d2d2e13697df135255a90/50e7d/23.png 1738w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p>Puedes descargar el certificado de finalización de esta parte dando click en uno de los íconos de las banderas. Cada bandera corresponde con el idioma del certificado.</p>\n<h3>Herramientas del oficio</h3>\n<p>Las herramientas básicas que necesitará varían de acuerdo a los sistemas operativos:</p>\n<ul>\n<li><a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-win10\">WSL 2 terminal</a> en Windows</li>\n<li>Terminal en Mac</li>\n<li>Command Line en Linux</li>\n</ul>\n<h3>Instalando todo lo necesario para esta parte</h3>\n<p>Comenzaremos instalando el software necesario. El paso de instalación será uno de los posibles obstáculos. Como estamos tratando con la virtualización a nivel del sistema operativo, las herramientas requerirán acceso de superusuario en la computadora. Tendrán acceso al kernel de su sistema operativo.</p>\n<p>Este material está basado en <a href=\"https://www.docker.com/\">Docker</a>, un conjunto de productos que utilizaremos para la contenerización y la administración de los contenedores. Desafortunadamente si no puedes instalar Docker probablemente no podrás completar esta parte.</p>\n<p>Como las instrucciones de instalación dependen de su sistema operativo, deberá encontrar las instrucciones de instalación correctas en el siguiente enlace. Tenga en cuenta que pueden tener múltiples opciones diferentes para su sistema operativo.</p>\n<ul>\n<li><a href=\"https://docs.docker.com/get-docker/\">Obtén Docker</a></li>\n</ul>\n<p>Ahora que esperamos que ese dolor de cabeza haya terminado, asegurémonos de que nuestras versiones coincidan. El tuyo puede tener números un poco más altos:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> <span class=\"token parameter variable\">-v</span>\nDocker version <span class=\"token number\">20.10</span>.5, build 55c4c88</code></pre></div>\n<h3>Contenedores e imágenes</h3>\n<p>Hay dos conceptos básicos al comenzar con los contenedores y son fáciles de confundir entre sí:</p>\n<p>Un <strong>contenedor</strong> es una instancia en tiempo de ejecución de una <strong>imagen</strong>.</p>\n<p>Las dos afirmaciones siguientes son verdaderas:</p>\n<ul>\n<li>Las imágenes incluyen todo el código, dependencias e instrucciones sobre cómo ejecutar la aplicación</li>\n<li>Software de paquete de contenedores en unidades estandarizadas</li>\n</ul>\n<p>No es de extrañar que se confundan fácilmente.</p>\n<p>Para ayudar con la confusión, casi todos usan la palabra contenedor para describir ambos. Pero en realidad nunca se puede construir un contenedor o descargar uno, ya que los contenedores solo existen durante el tiempo de ejecución. Las imágenes, por otro lado, son archivos <strong>inmutables</strong>. Como resultado de la inmutabilidad, no puede editar una imagen después de haberla creado. Sin embargo, puede usar imágenes existentes para crear <i>una nueva imagen</i> agregando nuevas capas encima de las existentes.</p>\n<p>Metáfora de la cocina:</p>\n<ul>\n<li>La imagen es una golosina precocinada y congelada.</li>\n<li>El contenedor es el delicioso manjar.</li>\n</ul>\n<p><a href=\"https://www.docker.com/\">Docker</a> es la tecnología de contenedorización más popular y fue pionera en los estándares que la mayoría de las tecnologías de contenedorización utilizan en la actualidad. En la práctica, Docker es un conjunto de productos que nos ayudan a gestionar imágenes y contenedores. Este conjunto de productos nos permitirá aprovechar todos los beneficios de los contenedores. Por ejemplo, el motor de la ventana acoplable se encargará de convertir los archivos inmutables llamados imágenes en contenedores.</p>\n<p>Para administrar los contenedores docker, también existe una herramienta llamada <a href=\"https://docs.docker.com/compose/\">Docker Compose</a> que permite <strong>orquestar</strong> (controlar) varios contenedores al mismo tiempo. En esta parte, utilizaremos Docker Compose para configurar un entorno de desarrollo local complejo. En la versión final del entorno de desarrollo que configuramos, incluso instalar Node en nuestra máquina ya no es un requisito.</p>\n<p>Hay varios conceptos que necesitamos repasar. ¡Pero los omitiremos por ahora y aprenderemos sobre Docker primero!</p>\n<p>Comencemos con el comando <i>docker container run</i> que se usa para ejecutar imágenes dentro de un contenedor. La estructura del comando es la siguiente: <em>container run <i>IMAGE-NAME</i></em> le indicaremos a Docker que cree un contenedor a partir de una imagen. Una característica particularmente interesante del comando es que puede ejecutar un contenedor incluso si la imagen para ejecutar aún no se ha descargado en nuestro dispositivo.</p>\n<p>Ejecutemos el comando</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">§ <span class=\"token function\">docker</span> container run hello-world</code></pre></div>\n<p>Habrá muchos resultados, pero dividámoslos en varias secciones, que podemos descifrar juntos. Las líneas están numeradas para que sea más fácil seguir la explicación. Su salida no tendrá los números.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">1</span>. Unable to <span class=\"token function\">find</span> image <span class=\"token string\">'hello-world:latest'</span> locally\n<span class=\"token number\">2</span>. latest: Pulling from library/hello-world\n<span class=\"token number\">3</span>. b8dfde127a29: Pull complete\n<span class=\"token number\">4</span>. Digest: sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c\n<span class=\"token number\">5</span>. Status: Downloaded newer image <span class=\"token keyword\">for</span> hello-world:latest</code></pre></div>\n<p>Debido a que la imagen <i>hello-world</i> no se encontró en nuestra máquina, el comando primero la descargó de un registro gratuito llamado <a href=\"https://hub.docker.com/\">Docker Hub</a>. Puede ver la página de Docker Hub de la imagen con su navegador aquí: <a href=\"https://hub.docker.com/_/hello-world\">https://hub.docker.com/_/hello-world</a></p>\n<p>La primera parte del mensaje indica que aún no teníamos la imagen \"hello-world:latest\". Esto revela un poco de detalle sobre las imágenes mismas; los nombres de las imágenes constan de varias partes, como una URL. El nombre de una imagen tiene el siguiente formato:</p>\n<ul>\n<li><em>registry/organisation/image:tag</em></li>\n</ul>\n<p>En este caso, los 3 campos que faltan resultan por defecto: </p>\n<ul>\n<li><em>index.docker.io/library/hello-world:latest</em></li>\n</ul>\n<p>La segunda fila muestra el nombre de la organización, \"biblioteca\" donde obtendrá la imagen. En la URL de Docker Hub, la \"biblioteca\" se acorta a _.</p>\n<p>Las filas 3 y 5 solo muestran el estado. Pero la cuarta fila puede ser interesante: cada imagen tiene un resumen único basado en las <i>capas</i> a partir de las cuales se construye la imagen. En la práctica, cada paso o comando que se usó para construir la imagen crea una capa única. Docker usa el resumen para identificar que una imagen es la misma. Esto se hace cuando intenta extraer la misma imagen nuevamente.</p>\n<p>Entonces, el resultado de usar el comando fue extraer y luego generar información sobre la <strong>imagen</strong>. Después de eso, el estado nos dijo que se descargó una nueva versión de hello-world:latest. Puede intentar extraer la imagen con <em>docker image pull hello-world</em> y ver qué sucede.</p>\n<p>El siguiente resultado fue del propio contenedor. También explica lo que sucedió cuando ejecutamos <em>docker container run hello-world</em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">Hello from Docker<span class=\"token operator\">!</span>\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n <span class=\"token number\">1</span>. The Docker client contacted the Docker daemon.\n <span class=\"token number\">2</span>. The Docker daemon pulled the <span class=\"token string\">\"hello-world\"</span> image from the Docker Hub.\n    <span class=\"token punctuation\">(</span>amd64<span class=\"token punctuation\">)</span>\n <span class=\"token number\">3</span>. The Docker daemon created a new container from that image <span class=\"token function\">which</span> runs the\n    executable that produces the output you are currently reading.\n <span class=\"token number\">4</span>. The Docker daemon streamed that output to the Docker client, <span class=\"token function\">which</span> sent it\n    to your terminal.\n\nTo try something <span class=\"token function\">more</span> ambitious, you can run an Ubuntu container with:\n $ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">-it</span> ubuntu <span class=\"token function\">bash</span>\n\nShare images, automate workflows, and <span class=\"token function\">more</span> with a <span class=\"token function\">free</span> Docker ID:\n https://hub.docker.com/\n\nFor <span class=\"token function\">more</span> examples and ideas, visit:\n https://docs.docker.com/get-started/</code></pre></div>\n<p>El resultado contiene algunas cosas nuevas para que aprendamos. <i>Docker daemon</i> es un servicio en segundo plano que se asegura de que los contenedores se estén ejecutando y usamos el <i>Docker client</i> para interactuar con el daemon. Ahora hemos interactuado con la primera imagen y hemos creado un contenedor a partir de la imagen. Durante la ejecución de ese contenedor, recibimos la salida.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.2</h3>\n<p>Algunos de estos ejercicios no requieren que escriba ningún código o configuración en un archivo.\nEn estos ejercicios, debe usar el comando <a href=\"https://man7.org/linux/man-pages/man1/script.1.html\">script</a> para registrar los comandos que ha usado; pruébelo usted mismo con <em>script</em> para comenzar a grabar, <em>echo \"hello\"</em> para generar alguna salida y <em>exit</em> para detener la grabación. Guarda sus acciones en un nombre de archivo \"typescript\".</p>\n<p>Si <em>script</em> no funciona, puede simplemente copiar y pegar todos los comandos que utilizó en un archivo de texto.</p>\n<h4>Ejercicio 12.2: Ejecutar su segundo contenedor</h4>\n<blockquote>\n<p>Use <em>script</em> para registrar lo que hace, guarde el archivo en script-answers/exercise12_2.txt</p>\n</blockquote>\n<p>El resultado de hello-world nos dio una tarea ambiciosa que hacer. Haga lo siguiente</p>\n<p>Paso 1. Ejecute un contenedor de Ubuntu con el comando proporcionado por hello-world</p>\n<p>El paso 1 lo conectará directamente al contenedor con bash. Tendrá acceso a todos los archivos y herramientas dentro del contenedor. Los siguientes pasos se ejecutan dentro del contenedor:</p>\n<p>Paso 2. Cree el directorio <i>/usr/src/app</i></p>\n<p>Paso 3. Cree el archivo <i>/usr/src/app/index.js</i></p>\n<p>Paso 4. Ejecute <i>exit</i> para salir del contenedor</p>\n<p>Google debería poder ayudarlo a crear directorios y archivos.</p>\n</div>\n<div class=\"content\">\n<h3>Imagen de Ubuntu</h3>\n<p>El comando que acaba de usar para ejecutar el contenedor de ubuntu, <em>docker container run -it ubuntu bash</em>, contiene algunas adiciones al hello-world ejecutado anteriormente. Veamos el --help para obtener una mejor comprensión. Cortaré parte de la salida para que podamos centrarnos en las partes relevantes.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">--help</span>\n\nUsage:  <span class=\"token function\">docker</span> container run <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span> IMAGE <span class=\"token punctuation\">[</span>COMMAND<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>ARG<span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\nRun a <span class=\"token builtin class-name\">command</span> <span class=\"token keyword\">in</span> a new container\n\nOptions:\n  <span class=\"token punctuation\">..</span>.\n  -i, <span class=\"token parameter variable\">--interactive</span>                    Keep STDIN <span class=\"token function\">open</span> even <span class=\"token keyword\">if</span> not attached\n  -t, <span class=\"token parameter variable\">--tty</span>                            Allocate a pseudo-TTY\n  <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>Las dos opciones, o banderas, <em>-it</em> aseguran que podamos interactuar con el contenedor. Después de las opciones, definimos que la imagen a ejecutar es <em>ubuntu</em>. Luego tenemos el comando <em>bash</em> que se ejecutará dentro del contenedor cuando lo iniciemos.</p>\n<p>Puede probar otros comandos que la imagen de ubuntu podría ejecutar. Como ejemplo, pruebe <em>docker container run --rm ubuntu ls</em>. El comando <em>ls</em> enumerará todos los archivos en el directorio y el indicador <em>--rm</em> eliminará el contenedor después de la ejecución. Normalmente, los contenedores no se eliminan automáticamente.</p>\n<p>Continuemos con nuestro primer contenedor de ubuntu con el archivo <strong>index.js</strong> dentro. El contenedor ha dejado de ejecutarse desde que salimos de él. Podemos enumerar todos los contenedores con <em>container ls -a</em>,la <em>-a</em> (o --all) enumerará los contenedores que ya se han cerrado.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                            NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">3</span> minutes ago    Exited <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">6</span> seconds ago          hopeful_clarke</code></pre></div>\n<p>Tenemos dos opciones a la hora de abordar un contenedor. El identificador de la primera columna se puede utilizar para interactuar con el contenedor casi siempre. Además, la mayoría de los comandos aceptan el nombre del contenedor como un método más amigable para trabajar con ellos. El nombre del contenedor se generó automáticamente para ser <strong>\"hopeful_clarke\"</strong> en mi caso.</p>\n<p>El contenedor ya salió, pero podemos iniciarlo de nuevo con el comando de inicio que aceptará la identificación o el nombre del contenedor como parámetro: <em>start <i>CONTAINER-ID-OR-CONTAINER-NAME</i></em>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> start hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p>El comando iniciará el mismo contenedor que teníamos anteriormente. Desafortunadamente, olvidamos iniciarlo con la bandera <em>--interactive</em> por lo que no podemos interactuar con él.</p>\n<p>El contenedor está realmente en funcionamiento como muestra el comando <em>container ls -a</em>, pero simplemente no podemos comunicarlo:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                            NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">7</span> minutes ago    Up <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">15</span> seconds ago            hopeful_clarke</code></pre></div>\n<p>Tenga en cuenta que también podemos ejecutar el comando sin la marca <em>-a</em> para ver solo los contenedores que se están ejecutando:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS             NAMES\n8f5abc55242a   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">8</span> minutes ago    Up <span class=\"token number\">1</span> minutes       hopeful_clarke             </code></pre></div>\n<p>Terminémoslo con el comando <em>kill <i>CONTAINER-ID-OR-CONTAINER-NAME</i></em> e intente nuevamente.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> <span class=\"token function\">kill</span> hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p><em>docker kill</em> envía una <a href=\"https://man7.org/linux/man-pages/man7/signal.7.html\">señal SIGKILL</a> al proceso forzándolo a salir, y eso hace que el contenedor se detenga. Podemos verificar su estado con <em>container ls -a</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED             STATUS                     NAMES\nb8548b9faec3   ubuntu     <span class=\"token string\">\"bash\"</span>   <span class=\"token number\">26</span> minutes ago      Exited <span class=\"token number\">2</span> seconds ago       hopeful_clarke</code></pre></div>\n<p>Ahora comencemos el contenedor de nuevo, pero esta vez en modo interactivo:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> start <span class=\"token parameter variable\">-i</span> hopeful_clarke\nroot@b8548b9faec3:/<span class=\"token comment\">#</span></code></pre></div>\n<p>Editemos el archivo <i>index.js</i> y agreguemos código JavaScript para ejecutar. Solo nos faltan las herramientas para editar el archivo. Nano será un buen editor de texto por ahora. Las instrucciones de instalación se encontraron en el primer resultado de Google. Omitiremos usar sudo ya que ya somos root.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@b8548b9faec3:/<span class=\"token comment\"># apt-get update</span>\nroot@b8548b9faec3:/<span class=\"token comment\"># apt-get -y install nano</span>\nroot@b8548b9faec3:/<span class=\"token comment\"># nano /usr/src/app/index.js</span></code></pre></div>\n<p>¡Ahora tenemos nano instalado y podemos comenzar a editar archivos!</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.3 - 12.4</h3>\n<h4>Ejercicio 12.3: Ubuntu 101</h4>\n<blockquote>\n<p>Use <em>script</em> para registrar lo que hace, guarde el archivo en script-answers/exercise12_3.txt</p>\n</blockquote>\n<p>Edite el archivo <em>/usr/src/app/index.js</em> dentro del contenedor con Nano y agregue la siguiente línea</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello World'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Si no está familiarizado con Nano, puede pedir ayuda en el chat o en Google.</p>\n<h4>Ejercicio 12.4: Ubuntu 102</h4>\n<blockquote>\n<p>Use <em>script</em> para registrar lo que hace, guarde el archivo en script-answers/exercise12_4.txt</p>\n</blockquote>\n<p>Instale Node mientras está dentro del contenedor y ejecute el archivo de índice con <em>node /usr/src/app/index.js</em> en el contenedor.</p>\n<p>Las instrucciones para instalar Node a veces son difíciles de encontrar, así que aquí hay algo que puede copiar y pegar:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-sL</span> https://deb.nodesource.com/setup_16.x <span class=\"token operator\">|</span> <span class=\"token function\">bash</span>\n<span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token parameter variable\">-y</span> nodejs</code></pre></div>\n<p>Deberá instalar <em>curl</em> en el contenedor. Se instala de la misma manera que lo hizo con <em>nano</em>.</p>\n<p>Después de la instalación, asegúrese de que puede ejecutar su código dentro del contenedor con el comando</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@b8548b9faec3:/# node /usr/src/app/index.js\nHello World</code></pre></div>\n</div>\n<div class=\"content\">\n<h3>Otros comandos de docker</h3>\n<p>¡Ahora que tenemos Node instalado, podemos ejecutar JavaScript en el contenedor! Vamos a crear una nueva imagen desde el contenedor. El <em>commit <i>CONTAINER-ID-OR-CONTAINER-NAME</i> <i>NEW-IMAGE-NAME</i></em> creará una nueva imagen que incluye los cambios que hemos realizado. Puede usar <em>container diff</em> para verificar los cambios entre la imagen original y el contenedor antes de hacerlo.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> commit hopeful_clarke hello-node-world</code></pre></div>\n<p>Puede enumerar sus imágenes con <em>image ls</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> image <span class=\"token function\">ls</span>\nREPOSITORY                                      TAG         IMAGE ID       CREATED         SIZE\nhello-node-world                                latest      eef776183732   <span class=\"token number\">9</span> minutes ago   252MB\nubuntu                                          latest      1318b700e415   <span class=\"token number\">2</span> weeks ago     <span class=\"token number\">72</span>.8MB\nhello-world                                     latest      d1165f221234   <span class=\"token number\">5</span> months ago    <span class=\"token number\">13</span>.3kB</code></pre></div>\n<p>Ahora puede ejecutar la nueva imagen de la siguiente manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> hello-node-world <span class=\"token function\">bash</span>\nroot@4d1b322e1aff:/<span class=\"token comment\"># node /usr/src/app/index.js</span></code></pre></div>\n<p>Hay varias formas de llegar a la misma conclusión. Vayamos a través de una mejor solución. Limpiaremos la pizarra con <em>container rm</em> para retirar el contenedor antiguo.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span> <span class=\"token parameter variable\">-a</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED          STATUS                  NAMES\nb8548b9faec3   ubuntu    <span class=\"token string\">\"bash\"</span>    <span class=\"token number\">31</span> minutes ago   Exited <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token number\">9</span> seconds ago               hopeful_clarke\n\n$ <span class=\"token function\">docker</span> container <span class=\"token function\">rm</span> hopeful_clarke\nhopeful_clarke</code></pre></div>\n<p>Cree un archivo <i>index.js</i> en su directorio actual y escriba <em>console.log('Hello, World')</em> dentro de él. No hay necesidad de contenedores todavía.</p>\n<p>A continuación, nos saltaremos la instalación manual de Node por completo. Hay muchas imágenes útiles de Docker en Docker Hub, listas para nuestro uso. Usemos la imagen <a href=\"https://hub.docker.com/_/Node\">https://hub.docker.com/_/Node</a>, que ya tiene Node instalado. Sólo tenemos que elegir una versión.</p>\n<p>Por cierto, el <em>container run</em> acepta el indicador <em>--name</em> que podemos usar para dar un nombre al contenedor.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container run <span class=\"token parameter variable\">-it</span> <span class=\"token parameter variable\">--name</span> hello-node node:16 <span class=\"token function\">bash</span></code></pre></div>\n<p>Vamos a crear un directorio para el código dentro del contenedor:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">root@77d1023af893:/# mkdir /usr/src/app</code></pre></div>\n<p>Mientras estamos dentro del contenedor en esta terminal, abra otra terminal y use el comando <em>container cp</em> para copiar el archivo desde su propia máquina al contenedor.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">cp</span> ./index.js hello-node:/usr/src/app/index.js</code></pre></div>\n<p>Y ahora podemos ejecutar <em>node /usr/src/app/index.js</em> en el contenedor. Podemos guardar esto como otra imagen nueva, pero hay una solución aún mejor. La siguiente sección tratará sobre la construcción de sus imágenes como un profesional.</p>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/09ec6709015c0dcb492111bd9e645d3d/part-12.svg"},"part":12,"letter":"a","lang":"es"}}},"pageContext":{"part":12,"letter":"a","lang":"es"}},"staticQueryHashes":["3128451518"]}