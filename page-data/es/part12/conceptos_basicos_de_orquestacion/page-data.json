{"componentChunkName":"component---src-templates-content-template-js","path":"/es/part12/conceptos_basicos_de_orquestacion","result":{"data":{"markdownRemark":{"html":"<div class=\"content\">\n<h3>React in container</h3>\n<p>Vamos a crear y contenerizar una aplicación React a continuación. Elijamos npm como administrador de paquetes aunque create-react-app tenga como valor predeterminado yarn.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npx create-react-app hello-front --use-npm\n  ...\n\n  Happy hacking!</code></pre></div>\n<p>create-react-app ya instaló todas las dependencias para nosotros, por lo que no necesitamos ejecutar npm install aquí.</p>\n<p>El siguiente paso es convertir el código JavaScript y CSS en archivos estáticos listos para producción, create-react-app ya tiene <em>build</em> como un script npm, así que usemos eso:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm run build\n  ...\n\n  Creating an optimized production build...\n  ...\n  The build folder is ready to be deployed.\n  ...</code></pre></div>\n<p>¡Excelente! El paso final es encontrar una forma de usar un servidor para servir los archivos estáticos. Como sabrás, podríamos usar nuestro <a href=\"https://expressjs.com/en/starter/static-files.html\">express.static</a> con el servidor Express para servir los archivos estáticos. Te lo dejo como ejercicio para que lo hagas en casa. En su lugar, seguiremos adelante y comenzaremos a escribir nuestro Dockerfile:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm run build</span></code></pre></div>\n<p>Eso parece correcto. Construyámoslo y veamos si estamos en el camino correcto. Nuestro objetivo es que la compilación tenga éxito sin errores. Luego usaremos bash para verificar dentro del contenedor para ver si los archivos están allí.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> build <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-t</span> hello-front\n  <span class=\"token punctuation\">[</span>+<span class=\"token punctuation\">]</span> Building <span class=\"token number\">172</span>.4s <span class=\"token punctuation\">(</span><span class=\"token number\">10</span>/10<span class=\"token punctuation\">)</span> FINISHED \n\n$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-it</span> hello-front <span class=\"token function\">bash</span>\n\nroot@98fa9483ee85:/usr/src/app<span class=\"token comment\"># ls</span>\n  Dockerfile  README.md  build  node_modules  package-lock.json  package.json  public  src\n\nroot@98fa9483ee85:/usr/src/app<span class=\"token comment\"># ls build/</span>\n  asset-manifest.json  favicon.ico  index.html  logo192.png  logo512.png  manifest.json  robots.txt  static</code></pre></div>\n<p>Una opción válida para servir archivos estáticos ahora que ya tenemos Node en el contenedor es <a href=\"https://www.npmjs.com/package/serve\">serve</a>. Intentemos instalar el servicio y servir los archivos estáticos mientras estamos dentro del contenedor.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@98fa9483ee85:/usr/src/app<span class=\"token comment\"># npm install -g serve</span>\n\n  added <span class=\"token number\">88</span> packages, and audited <span class=\"token number\">89</span> packages <span class=\"token keyword\">in</span> 6s\n\nroot@98fa9483ee85:/usr/src/app<span class=\"token comment\"># serve build</span>\n\n   ┌───────────────────────────────────┐\n   │                                   │\n   │   Serving<span class=\"token operator\">!</span>                        │\n   │                                   │\n   │   Local:  http://localhost:5000   │\n   │                                   │\n   └───────────────────────────────────┘</code></pre></div>\n<p>¡Excelente! Hagamos ctrl+c y salgamos y luego agréguelos a nuestro Dockerfile.</p>\n<p>La instalación de serve se convierte en RUN en el Dockerfile. De esta manera, la dependencia se instala durante el proceso de compilación. El comando para servir el directorio de compilación se convertirá en el comando para iniciar el contenedor:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm run build</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm install -g serve</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"serve\"</span>, <span class=\"token string\">\"build\"</span>]</span></code></pre></div>\n<p>Nuestro CMD ahora incluye corchetes y, como resultado, usamos el llamado <i>exec form</i> de CMD. En realidad, hay <strong>tres</strong> formas diferentes para el CMD de las cuales se prefiere la forma exec. Lea la <a href=\"https://docs.docker.com/engine/reference/builder/#cmd\">documentación</a> para obtener más información.</p>\n<p>Cuando ahora construimos la imagen con <em>docker build. -t hello-front</em> y la ejecutamos con <em>docker run -p 5000:3000 hello-front</em>, la aplicación estará disponible en <a href=\"http://localhost:5000\">http://localhost:5000</a>.</p>\n<h3>Usando múltiples etapas</h3>\n<p>Si bien serve es una opción <i>válida</i>, podemos hacerlo mejor. Un buen objetivo es crear imágenes de Docker para que no contengan nada irrelevante. Con un número mínimo de dependencias, es menos probable que las imágenes se rompan o se vuelvan vulnerables con el tiempo.</p>\n<p><a href=\"https://docs.docker.com/develop/develop-images/multistage-build/\">Compilaciones de varias etapas</a> están diseñadas para dividir el proceso de compilación en muchas etapas separadas, donde es posible limitar qué partes de los archivos de imagen se mueven entre las etapas. Eso abre posibilidades para limitar el tamaño de la imagen, ya que no todos los subproductos de la construcción son necesarios para la imagen resultante. Las imágenes más pequeñas son más rápidas de cargar y descargar y ayudan a reducir la cantidad de vulnerabilidades que puede tener su software.</p>\n<p>Con compilaciones de varias etapas, se puede usar una solución probada y verdadera como <a href=\"https://en.wikipedia.org/wiki/Nginx\">Nginx</a> para servir archivos estáticos sin muchos dolores de cabeza. La <a href=\"https://hub.docker.com/_/nginx\">página de Nginx</a> de Docker Hub nos brinda la información necesaria para abrir los puertos y \"Alojamiento de contenido estático simple\".</p>\n<p>Usemos el Dockerfile anterior pero cambiemos FROM para incluir el nombre de la etapa:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># The first FROM is now a stage called build-stage</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16 <span class=\"token keyword\">AS</span> build-stage</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm ci</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm run build</span>\n\n<span class=\"token comment\"># This is a new stage, everything before this is gone, except the files we want to COPY</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> nginx:1.20-alpine</span>\n<span class=\"token comment\"># COPY the directory build from build-stage to /usr/share/nginx/html</span>\n<span class=\"token comment\"># The target location here was found from the docker hub page</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">build-stage</span></span> /usr/src/app/build /usr/share/nginx/html</span></code></pre></div>\n<p>Hemos declarado también <i>otra etapa</i> donde solo se mueven los archivos relevantes de la primera etapa (el directorio <i>build</i>, que contiene el contenido estático).</p>\n<p>Después de que la construimos de nuevo, la imagen está lista para servir el contenido estático. El puerto predeterminado será 80 para Nginx, por lo que algo como <em>-p 8000:80</em> funcionará, por lo que los parámetros del comando de ejecución deben cambiarse un poco.</p>\n<p>Las compilaciones de varias etapas también incluyen algunas optimizaciones internas que pueden afectar sus compilaciones. Como ejemplo, las compilaciones de varias etapas se saltan las etapas que no se utilizan. Si deseamos usar una etapa para reemplazar una parte de una canalización de compilación, como pruebas o notificaciones, debemos pasar <strong>algunos</strong> datos a las siguientes etapas. En algunos casos esto está justificado: copie el código de la etapa de prueba a la etapa de construcción. Esto garantiza que está compilando el código probado.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicios 12.13 - 12.14.</h3>\n<h4>Ejercicio 12.13: Fronted de la aplicación de tareas</h4>\n<p>Finalmente, llegamos a la interfaz (fronted) de la aplicación de tareas pendientes. Vea todo-app/todo-frontend y lea el LÉAME.</p>\n<p>Comience ejecutando el frontend fuera del contenedor y asegúrese de que funcione con el backend.</p>\n<p>Contenga la aplicación creando <i>todo-app/todo-frontend/Dockerfile</i> y use la instrucción <a href=\"https://docs.docker.com/engine/reference/builder/#env\">ENV</a> para pasar * REACT_APP_BACKEND_URL* a la aplicación y ejecútela con el backend. El backend aún debería estar ejecutándose fuera de un contenedor. Tenga en cuenta que debe configurar <em>REACT_APP_BACKEND_URL</em> antes de compilar la interfaz, de lo contrario, no quedará definida en el código.</p>\n<h4>Ejercicio 12.14: Pruebas durante el proceso de construcción</h4>\n<p>Una posibilidad interesante de utilizar compilaciones de varias etapas es usar una etapa de compilación separada para <a href=\"https://docs.docker.com/language/nodejs/run-tests/\">pruebas</a>. Si la etapa de prueba falla, todo el proceso de construcción también fallará. Tenga en cuenta que puede que no sea la mejor idea mover <i>todas las pruebas</i> para que se realicen durante la construcción de una imagen, pero puede ser buena idea que existan <i>algunas</i> pruebas relacionadas con la creación de contenedores.</p>\n<p>Extraiga un componente <i>Todo</i> que represente una sola tarea. Escriba una prueba para el nuevo componente y agregue pruebas en ejecución al proceso de compilación.</p>\n<p>Ejecute las pruebas con <em>CI=true npm test</em>, o create-react-app comenzará a buscar cambios y su canalización se atascará.</p>\n<p>Puede agregar una nueva etapa de compilación para la prueba si lo desea. Si lo hace, ¡recuerde leer de nuevo el último párrafo antes del ejercicio 12.13!</p>\n</div>\n<div class=\"content\">\n<h3>Desarrollo en contenedores</h3>\n<p>Movamos todo el desarrollo de la aplicación de tareas pendientes a un contenedor. Hay algunas razones por las que querrías hacer eso:</p>\n<ul>\n<li>Para mantener el entorno similar entre el desarrollo y la producción para evitar errores que aparecen solo en el entorno de producción.</li>\n<li>Evitar diferencias entre los desarrolladores y sus entornos personales que generen dificultades en el desarrollo de aplicaciones.</li>\n<li>Para ayudar a los nuevos miembros del equipo a incorporarse, haciéndoles instalar el tiempo de ejecución del contenedor, sin necesidad de nada más.</li>\n</ul>\n<p>Todas estas son buenas razones. La contrapartida es que podemos encontrarnos con algún comportamiento no convencional cuando no estamos ejecutando las aplicaciones a las que estamos acostumbrados. Tendremos que hacer al menos dos cosas para mover la aplicación a un contenedor:</p>\n<ul>\n<li>Inicie la aplicación en modo de desarrollo</li>\n<li>Accede a los archivos con VSCode</li>\n</ul>\n<p>Comencemos con la interfaz. Dado que el Dockerfile será significativamente diferente al Dockerfile de producción, creemos uno nuevo llamado <i>dev.Dockerfile</i>.</p>\n<p>Iniciar la aplicación create-react-app en modo de desarrollo debería ser fácil. Comencemos con lo siguiente:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> node:16</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /usr/src/app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n\n<span class=\"token comment\"># Change npm ci to npm install since we are going to be in development mode</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> npm install</span>\n\n<span class=\"token comment\"># npm start is the command to start the application in development mode</span>\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"npm\"</span>, <span class=\"token string\">\"start\"</span>]</span></code></pre></div>\n<p>Durante la compilación, se usará el indicador <em>-f</em> para indicar qué archivo usar; de lo contrario, sería Dockerfile predeterminado, por lo que <em>docker build -f ./dev.Dockerfile -t hello-front-dev .</em> compilará la imagen. La aplicación create-react se servirá en el puerto 3000, por lo que puede probar que funciona ejecutando un contenedor con ese puerto publicado.</p>\n<p>La segunda tarea, acceder a los archivos con VSCode, aún no se ha realizado. Hay al menos dos formas de hacer esto:</p>\n<ul>\n<li><a href=\"https://code.visualstudio.com/docs/remote/containers\">Extensión de Visual Studio Code Remote - Containers</a></li>\n<li>Volúmenes, lo mismo que usamos para conservar los datos con la base de datos.</li>\n</ul>\n<p>Repasemos esto último, ya que también funcionará con otros editores. Hagamos una ejecución de prueba con el indicador <em>-v</em> y, si funciona, moveremos la configuración a un archivo docker-compose. Para usar <em>-v</em>, necesitaremos decirle el directorio actual. El comando <em>pwd</em> debería generar la ruta al directorio actual. Intente esto con <em>echo $(pwd)</em> en su línea de comando. Podemos usarlo con <em>-v</em> a la izquierda para asignar el directorio actual al interior del contenedor o puede usar la ruta completa del directorio.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> run <span class=\"token parameter variable\">-p</span> <span class=\"token number\">3000</span>:3000 <span class=\"token parameter variable\">-v</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token builtin class-name\">pwd</span><span class=\"token variable\">)</span></span>:/usr/src/app/\"</span> hello-front-dev\n\n  Compiled successfully<span class=\"token operator\">!</span>\n\n  You can now view hello-front <span class=\"token keyword\">in</span> the browser.</code></pre></div>\n<p>Ahora podemos editar el archivo <i>src/App.js</i>, ¡y los cambios deben cargarse de forma instantanea en el navegador!</p>\n<p>A continuación, movamos la configuración a <i>docker-compose.yml</i>. Ese archivo también debe estar en la raíz del proyecto:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> . <span class=\"token comment\"># The context will pick this directory as the \"build context\"</span>\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile <span class=\"token comment\"># This will simply tell which dockerfile to read</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app <span class=\"token comment\"># The path can be relative, so ./ is enough to say \"the same location as the docker-compose.yml\"</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 3000<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev <span class=\"token comment\"># This will name the container hello-front-dev</span></code></pre></div>\n<p>Con esta configuración, <em>docker-compose up</em> puede ejecutar la aplicación en modo de desarrollo. ¡Ni siquiera necesita Node instalado para desarrollarlo!</p>\n<p>Instalar nuevas dependencias es un dolor de cabeza para una configuración de desarrollo como esta. Una de las mejores opciones es instalar la nueva dependencia <strong>dentro</strong> del contenedor. Entonces, en lugar de hacer, p. <em>npm install axios</em>, debe hacerlo en el contenedor en ejecución, p. <em>docker exec hello-front-dev npm instale axios</em>, o agréguelo a package.json y ejecute <em>docker build</em> nuevamente.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.15</h3>\n<h4>Ejercicio 12.15: Configurar un entorno de desarrollo frontend</h4>\n<p>Cree <i>todo-frontend/docker-compose.dev.yml</i> y use volúmenes para habilitar el desarrollo de todo-frontend mientras se ejecuta <i>dentro</i> de un contenedor.</p>\n</div>\n<div class=\"content\">\n<h3>Comunicación entre contenedores en una red Docker</h3>\n<p>La herramienta docker-compose configura una red entre los contenedores e incluye un DNS para conectar fácilmente dos contenedores. Agreguemos un nuevo servicio a docker-compose y veremos cómo funcionan la red y el DNS.</p>\n<p><a href=\"https://www.busybox.net/\">Busybox</a> es un pequeño ejecutable con varias herramientas que puede necesitar. Se llama \"La navaja suiza de Embedded Linux\", y definitivamente podemos usarlo para nuestro beneficio.</p>\n<p>Busybox puede ayudarnos a depurar nuestras configuraciones. Entonces, si se pierde en los ejercicios posteriores de esta sección, debe usar Busybox para averiguar qué funciona y qué no. Usémoslo para explorar lo que se acaba de decir. Que los contenedores están dentro de una red y puede conectarse fácilmente entre ellos. Busybox se puede agregar a la mezcla cambiando <i>docker-compose.yml</i> a:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 3000<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token key atrule\">debug-helper</span><span class=\"token punctuation\">:</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox</span></code></pre></div>\n<p>El contenedor Busybox no tendrá ningún proceso ejecutándose dentro para que podamos <em>ejecutar</em> allí. Por eso, la salida de <em>docker-compose up</em> también se verá así:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker-compose</span> up\n  Pulling debug-helper <span class=\"token punctuation\">(</span>busybox:<span class=\"token punctuation\">)</span><span class=\"token punctuation\">..</span>.\n  latest: Pulling from library/busybox\n  8ec32b265e94: Pull complete\n  Digest: sha256:b37dd066f59a4961024cf4bed74cae5e68ac26b48807292bd12198afa3ecb778\n  Status: Downloaded newer image <span class=\"token keyword\">for</span> busybox:latest\n  Starting hello-front-dev          <span class=\"token punctuation\">..</span>. <span class=\"token keyword\">done</span>\n  Creating react-app_debug-helper_1 <span class=\"token punctuation\">..</span>. <span class=\"token keyword\">done</span>\n  Attaching to react-app_debug-helper_1, hello-front-dev\n  react-app_debug-helper_1 exited with code <span class=\"token number\">0</span>\n  \n  hello-front-dev <span class=\"token operator\">|</span> \n  hello-front-dev <span class=\"token operator\">|</span> <span class=\"token operator\">></span> react-app@0.1.0 start\n  hello-front-dev <span class=\"token operator\">|</span> <span class=\"token operator\">></span> react-scripts start</code></pre></div>\n<p>Esto es de esperar ya que es solo una caja de herramientas. Usémoslo para enviar una solicitud a hello-front-dev y ver cómo funciona el DNS. Mientras se ejecuta hello-front-dev, podemos realizar la solicitud con <a href=\"https://en.wikipedia.org/wiki/Wget\">wget</a> ya que es una herramienta incluida en Busybox para enviar una solicitud desde el asistente de depuración. a hola-front-dev.</p>\n<p>Con Docker Compose podemos usar <em>docker-compose run SERVICE COMMAND</em> para ejecutar un servicio con un comando específico. El comando wget requiere la bandera <em>-O</em> con <em>-</em> para generar la respuesta a la salida estándar:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker-compose</span> run debug-helper <span class=\"token function\">wget</span> <span class=\"token parameter variable\">-O</span> - http://app:3000\n\n  Creating react-app_debug-helper_run <span class=\"token punctuation\">..</span>. <span class=\"token keyword\">done</span>\n  Connecting to hello-front-dev:3000 <span class=\"token punctuation\">(</span><span class=\"token number\">172.26</span>.0.2:3000<span class=\"token punctuation\">)</span>\n  writing to stdout\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span>DOCTYPE html<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>html <span class=\"token assign-left variable\">lang</span><span class=\"token operator\">=</span><span class=\"token string\">\"en\"</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>head<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>meta <span class=\"token assign-left variable\">charset</span><span class=\"token operator\">=</span><span class=\"token string\">\"utf-8\"</span> /<span class=\"token operator\">></span>\n      <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>La URL es la parte interesante aquí. Simplemente dijimos que se conectará al servicio <i>hello-front-dev</i> y a ese puerto 3000. El <i>hello-front-dev</i> es el nombre del contenedor, que fue dado por nosotros usando <em>container_name</em> en el archivo docker-compose. Y el puerto utilizado es el puerto desde el cual la aplicación está disponible en ese contenedor. No es necesario publicar el puerto para que otros servicios de la misma red puedan conectarse a él. Los \"puertos\" en el archivo docker-compose son solo para acceso externo.</p>\n<p>Cambiemos la configuración del puerto en <i>docker-compose.yml</i> para enfatizar esto:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> dev.Dockerfile\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./<span class=\"token punctuation\">:</span>/usr/src/app\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">-</span> 3210<span class=\"token punctuation\">:</span><span class=\"token number\">3000</span></span>    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> hello<span class=\"token punctuation\">-</span>front<span class=\"token punctuation\">-</span>dev\n  <span class=\"token key atrule\">debug-helper</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> busybox</code></pre></div>\n<p>Con <em>docker-compose up</em> la aplicación está disponible en <a href=\"http://localhost:3210\">http://localhost:3210</a> en la <i>máquina host</i>, pero aun así <em>docker-compose ejecuta debug-helper wget -O - <a href=\"http://app\">http://app</a>: 3000</em> funciona ya que el puerto sigue siendo 3000 dentro de la red docker.</p>\n<picture><img src=\"/static/ecd3aa14ff1220e3f47ddd6b63116a48/efc6e/busybox_networking_drawio.png\" srcset=\"/static/ecd3aa14ff1220e3f47ddd6b63116a48/772e8/busybox_networking_drawio.png 200w,\n/static/ecd3aa14ff1220e3f47ddd6b63116a48/e17e5/busybox_networking_drawio.png 400w,\n/static/ecd3aa14ff1220e3f47ddd6b63116a48/efc6e/busybox_networking_drawio.png 441w\" sizes=\"(max-width: 441px) 100vw, 441px\"></picture>\n<p>Como ilustra la imagen de arriba, <em>docker-compose run</em> le pide a debug-helper que envíe la solicitud dentro de la red. Mientras que el navegador en la máquina host envía la solicitud desde fuera de la red.</p>\n<p>Ahora que sabe lo fácil que es encontrar otros servicios en <i>docker-compose.yml</i> y no tenemos nada que depurar, podemos eliminar el asistente de depuración y revertir los puertos a 3000:3000 en nuestro &#x3C; i>docker-compose.yml</i>.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicio 12.16</h3>\n<h4>Ejercicio 12.16: Ejecutar todo-backend en un contenedor de desarrollo</h4>\n<p>Use volúmenes y Nodemon para permitir el desarrollo del backend de la aplicación de tareas mientras se ejecuta <i>dentro</i> de un contenedor. Cree un <i>todo-backend/dev.Dockerfile</i> y edite <i>todo-backend/docker-compose.dev.yml</i>.</p>\n<p>También deberá repensar las conexiones entre el backend y MongoDB/Redis. Afortunadamente, docker-compose puede incluir variables de entorno que se pasarán a la aplicación:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token punctuation\">...</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span> \n      <span class=\"token punctuation\">-</span> REDIS_URL=<span class=\"token punctuation\">...</span>\n      <span class=\"token punctuation\">-</span> MONGO_URL=<span class=\"token punctuation\">...</span></code></pre></div>\n<p>Las URL (localhost) son incorrectas a propósito, deberá establecer los valores correctos. Recuerda <i>mirar todo el tiempo lo que sucede en la consola</i>. Si las cosas fallan, los mensajes de error insinúan lo que podría estar roto.</p>\n<p>Aquí hay una imagen posiblemente útil que ilustra las conexiones dentro de la red acoplable:</p>\n<picture><img src=\"/static/e866965c916d7f8e5a8515d3aa16bc44/85ff8/ex_12_15_backend_drawio.png\" srcset=\"/static/e866965c916d7f8e5a8515d3aa16bc44/772e8/ex_12_15_backend_drawio.png 200w,\n/static/e866965c916d7f8e5a8515d3aa16bc44/e17e5/ex_12_15_backend_drawio.png 400w,\n/static/e866965c916d7f8e5a8515d3aa16bc44/85ff8/ex_12_15_backend_drawio.png 467w\" sizes=\"(max-width: 467px) 100vw, 467px\"></picture>\n</div>\n<div class=\"content\">\n<h3>Comunicaciones entre contenedores en un entorno más ambicioso</h3>\n<p>A continuación, agregaremos un <a href=\"https://en.wikipedia.org/wiki/Reverse_proxy\">proxy inverso</a> a nuestro docker-compose.yml. segun wikipedia</p>\n<blockquote>\n<p><i>Un proxy inverso es un tipo de servidor proxy que recupera recursos en nombre de un cliente de uno o más servidores. Estos recursos luego se devuelven al cliente, apareciendo como si se originaran en el propio servidor proxy inverso.</i></p>\n</blockquote>\n<p>Entonces, en nuestro caso, el proxy inverso será el único punto de entrada a nuestra aplicación, y el objetivo final será establecer tanto el frontend de React como el backend de Express detrás del proxy inverso.</p>\n<p>Hay múltiples opciones diferentes para una implementación de proxy inverso, como Traefik, Caddy, Nginx y Apache (ordenadas por versión inicial de más reciente a más antigua).</p>\n<p>Nuestra elección es <a href=\"https://hub.docker.com/_/nginx\">Nginx</a>.</p>\n<p>Ahora pongamos <i>hello-frontend</i> detrás del proxy inverso.</p>\n<p>Cree un archivo <i>nginx.conf</i> en la raíz del proyecto y tome la siguiente plantilla como punto de partida. Tendremos que hacer ediciones menores para que nuestra aplicación se ejecute:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># events is required, but defaults are ok</span>\nevents <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># A http server, listening at port 80</span>\nhttp <span class=\"token punctuation\">{</span>\n  server <span class=\"token punctuation\">{</span>\n    listen <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\"># Requests starting with root (/) are handled</span>\n    location / <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\"># The following 3 lines are required for the hot loading to work (websocket).</span>\n      proxy_http_version <span class=\"token number\">1.1</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Upgrade <span class=\"token variable\">$http_upgrade</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Connection <span class=\"token string\">'upgrade'</span><span class=\"token punctuation\">;</span>\n      \n      <span class=\"token comment\"># Requests are directed to http://localhost:3000</span>\n      proxy_pass http://localhost:3000<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>A continuación, cree un servicio Nginx en el archivo <i>docker-compose.yml</i>. Agregue un volumen como se indica en la página de Docker Hub donde el lado derecho es <em>:/etc/nginx/nginx.conf:ro</em>, el ro final declara que el volumen será <i>de solo lectura</i>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">app</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># ...</span>\n  <span class=\"token key atrule\">nginx</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span>1.20.1\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ./nginx.conf<span class=\"token punctuation\">:</span>/etc/nginx/nginx.conf<span class=\"token punctuation\">:</span>ro\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> 8080<span class=\"token punctuation\">:</span><span class=\"token number\">80</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> reverse<span class=\"token punctuation\">-</span>proxy\n    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> app <span class=\"token comment\"># wait for the frontend container to be started</span></code></pre></div>\n<p>Con eso agregado, podemos ejecutar <em>docker-compose up</em> y ver qué sucede.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> container <span class=\"token function\">ls</span>\nCONTAINER ID   IMAGE             COMMAND                  CREATED         STATUS         PORTS                                       NAMES\na02ae58f3e8d   nginx:1.20.1      <span class=\"token string\">\"/docker-entrypoint.…\"</span>   <span class=\"token number\">4</span> minutes ago   Up <span class=\"token number\">4</span> minutes   <span class=\"token number\">0.0</span>.0.0:8080-<span class=\"token operator\">></span><span class=\"token number\">80</span>/tcp, :::8080-<span class=\"token operator\">></span><span class=\"token number\">80</span>/tcp       reverse-proxy\n5ee0284566b4   hello-front-dev   <span class=\"token string\">\"docker-entrypoint.s…\"</span>   <span class=\"token number\">4</span> minutes ago   Up <span class=\"token number\">4</span> minutes   <span class=\"token number\">0.0</span>.0.0:3000-<span class=\"token operator\">></span><span class=\"token number\">3000</span>/tcp, :::3000-<span class=\"token operator\">></span><span class=\"token number\">3000</span>/tcp   hello-front-dev</code></pre></div>\n<p>Conectarse a <a href=\"http://localhost:8080\">http://localhost:8080</a> conducirá a una página familiar con estado 502.</p>\n<p>Esto se debe a que dirigir las solicitudes a <a href=\"http://localhost:3000\">http://localhost:3000</a> no conduce a ninguna parte, ya que el contenedor Nginx no tiene una aplicación ejecutándose en el puerto 3000. Por definición, localhost se refiere a la computadora actual utilizada para acceder a él. Con los contenedores, localhost es único para cada contenedor, lo que lleva al contenedor en sí.</p>\n<p>Probemos esto ingresando al contenedor Nginx y usando curl para enviar una solicitud a la aplicación misma. En nuestro uso, curl es similar a wget, pero no necesitará ninguna bandera.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> <span class=\"token parameter variable\">-it</span> reverse-proxy <span class=\"token function\">bash</span>  \n\nroot@374f9e62bfa8:/<span class=\"token comment\"># curl http://localhost:80</span>\n  <span class=\"token operator\">&lt;</span>html<span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span>head<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>title<span class=\"token operator\">></span><span class=\"token number\">502</span> Bad Gateway<span class=\"token operator\">&lt;</span>/title<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>/head<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">..</span>.</code></pre></div>\n<p>Para ayudarnos, docker-compose configuró una red cuando ejecutamos <em>docker-compose up</em>. También agregó todos los contenedores en <i>docker-compose.yml</i> a la red. Un DNS se asegura de que podamos encontrar el otro contenedor. Cada uno de los contenedores recibe dos nombres: el nombre del servicio y el nombre del contenedor.</p>\n<p>Como estamos dentro del contenedor, ¡también podemos probar el DNS! Modifiquemos el nombre del servicio (aplicación) en el puerto 3000</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">root@374f9e62bfa8:/# curl http://app:3000\n  <span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span> <span class=\"token attr-name\">lang</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>en<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span>\n    ...\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>meta</span>\n      <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>description<span class=\"token punctuation\">\"</span></span>\n      <span class=\"token attr-name\">content</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Web site created using create-react-app<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token punctuation\">/></span></span>\n    ...</code></pre></div>\n<p>¡Eso es! Reemplacemos la dirección proxy_pass en nginx.conf con esa.</p>\n<p>Si todavía se encuentra con 502, asegúrese de que la aplicación create-react-app se haya creado primero. Puede leer la salida de registros desde <em>docker-compose up</em>.</p>\n<p>Una cosa más: agregamos una opción <a href=\"https://docs.docker.com/compose/compose-file/compose-file-v3/#depends_on\">depends_on</a> a la configuración que garantiza que el contenedor <em>nginx</em> no se inicie antes se mira el contenedor frontend <em>app</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">services:\n  app:\n    <span class=\"token comment\"># ...</span>\n  nginx:\n    image: nginx:1.20.1\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf:ro\n    ports:\n      - <span class=\"token number\">8080</span>:80\n    container_name: reverse-proxy\n<span class=\"gatsby-highlight-code-line\">    depends_on:</span><span class=\"gatsby-highlight-code-line\">      - app</span></code></pre></div>\n<p>Si no hacemos cumplir el orden de inicio con <i>depends_on</i>, existe el riesgo de que Nginx falle en el inicio, ya que intenta recuperar todos los nombres de DNS a los que se hace referencia en el archivo de configuración:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">http <span class=\"token punctuation\">{</span>\n  server <span class=\"token punctuation\">{</span>\n    listen <span class=\"token number\">80</span><span class=\"token punctuation\">;</span>\n\n    location / <span class=\"token punctuation\">{</span>\n      proxy_http_version <span class=\"token number\">1.1</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Upgrade <span class=\"token variable\">$http_upgrade</span><span class=\"token punctuation\">;</span>\n      proxy_set_header Connection <span class=\"token string\">'upgrade'</span><span class=\"token punctuation\">;</span>\n      \n<span class=\"gatsby-highlight-code-line\">      proxy_pass http://app:3000<span class=\"token punctuation\">;</span></span>    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Tenga en cuenta que <i>depends_on</i> no garantiza que el servicio en el contenedor dependiente esté listo para la acción, solo asegura que el contenedor se haya iniciado (y la entrada correspondiente se agregue a DNS). Si un servicio necesita esperar a que otro servicio esté listo antes del inicio, se deben usar <a href=\"https://docs.docker.com/compose/startup-order/\">otras soluciones</a>.</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicios 12.17. - 12.19.</h3>\n<h4>Ejercicio 12.17: Configure un servidor proxy inverso Nginx frente a todo-frontend</h4>\n<p>A continuación vamos a poner el servidor nginx delante de todo-frontend y todo-backend. Comencemos creando un nuevo archivo docker-compose <i>todo-app/docker-compose.dev.yml</i> y <i>todo-app/nginx.conf</i>.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">todo-app\n├── todo-frontend\n├── todo-backend\n<span class=\"gatsby-highlight-code-line\">├── nginx.conf</span><span class=\"gatsby-highlight-code-line\">└── docker-compose.dev.yml</span></code></pre></div>\n<p>Agregue los servicios nginx y todo-frontend creados con <i>todo-app/todo-frontend/dev.Dockerfile</i> en <i>todo-app/docker-compose.dev.yml</i>.</p>\n<picture><img src=\"/static/a5c3b8d70abca3569ed532e053af7bc7/15d25/ex_12_16_nginx_front.png\" srcset=\"/static/a5c3b8d70abca3569ed532e053af7bc7/772e8/ex_12_16_nginx_front.png 200w,\n/static/a5c3b8d70abca3569ed532e053af7bc7/e17e5/ex_12_16_nginx_front.png 400w,\n/static/a5c3b8d70abca3569ed532e053af7bc7/15d25/ex_12_16_nginx_front.png 497w\" sizes=\"(max-width: 497px) 100vw, 497px\"></picture>\n<h4>Ejercicio 12.18: Configure el servidor Nginx para que esté al frente de todo-backend</h4>\n<p>Agregue el servicio todo-backend al archivo docker-compose <i>todo-app/docker-compose.dev.yml</i> en el modo de desarrollo.</p>\n<p>Agregue una nueva ubicación a <i>nginx.conf</i> para que las solicitudes a <em>/api</em> se transmitan al backend. Algo como esto debería hacer el truco:</p>\n<div class=\"gatsby-highlight\" data-language=\"conf\"><pre class=\"language-conf\"><code class=\"language-conf\">  server {\n    listen 80;\n\n    # Requests starting with root (/) are handled\n    location / {\n      # The following 3 lines are required for the hot loading to work (websocket).\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection &#39;upgrade&#39;;\n      \n      # Requests are directed to http://localhost:3000\n      proxy_pass http://localhost:3000;\n    }\n\n    # Requests starting with /api/ are handled\n    location /api/ {\n      ...\n    }\n  }</code></pre></div>\n<p>La directiva <em>proxy_pass</em> tiene una característica interesante con una barra inclinada final. Como estamos usando la ruta <em>/api</em> para la ubicación, pero la aplicación backend solo responde en las rutas <em>/</em> o <em>/todos</em>, queremos que se elimine <em>/api</em> de la solicitud. En otras palabras, aunque el navegador envíe una solicitud GET a <em>/api/todos/1</em>, queremos que Nginx envíe la solicitud a <em>/todos/1</em>. Haga esto agregando una barra inclinada final <em>/</em> a la URL al final de <em>proxy_pass</em>.</p>\n<p>Este es un <a href=\"https://serverfault.com/questions/562756/how-to-remove-the-path-with-an-nginx-proxy-pass\">problema común</a></p>\n<picture><img src=\"/static/356d6b54ad3287d7e031093366b578bf/ace37/nginx_trailing_slash_stackoverflow.png\" srcset=\"/static/356d6b54ad3287d7e031093366b578bf/772e8/nginx_trailing_slash_stackoverflow.png 200w,\n/static/356d6b54ad3287d7e031093366b578bf/e17e5/nginx_trailing_slash_stackoverflow.png 400w,\n/static/356d6b54ad3287d7e031093366b578bf/ace37/nginx_trailing_slash_stackoverflow.png 666w\" sizes=\"(max-width: 666px) 100vw, 666px\"></picture>\n<p>Esto ilustra lo que estamos buscando y puede ser útil si tiene problemas:</p>\n<picture><img src=\"/static/1e05f9f899e31b8ec9044169ab3fb400/15d25/ex_12_17_nginx_back.png\" srcset=\"/static/1e05f9f899e31b8ec9044169ab3fb400/772e8/ex_12_17_nginx_back.png 200w,\n/static/1e05f9f899e31b8ec9044169ab3fb400/e17e5/ex_12_17_nginx_back.png 400w,\n/static/1e05f9f899e31b8ec9044169ab3fb400/15d25/ex_12_17_nginx_back.png 497w\" sizes=\"(max-width: 497px) 100vw, 497px\"></picture>\n<h4>Ejercicio 12.19: Conecte los servicios, todo-frontend con todo-backend</h4>\n<blockquote>\n<p>En este ejercicio, envíe todo el entorno de desarrollo, incluidas las aplicaciones Express y React, Dockerfiles y docker-compose.yml.</p>\n</blockquote>\n<p>Asegúrese de que todo-frontend funcione con todo-backend. Requerirá cambios en la variable ambiental <em>REACT_APP_BACKEND_URL</em>.</p>\n<p>Si ya hizo que esto funcionara durante un ejercicio anterior, puede omitirlo.</p>\n<p>Asegúrese de que el entorno de desarrollo ahora sea completamente funcional, es decir:</p>\n<ul>\n<li>todas las funciones de la aplicación de tareas funcionan</li>\n<li>puede editar los archivos fuente <i>y</i> los cambios surten efecto a través de la recarga instantanea en el caso del frontend y recargando la aplicación en el caso del backend.</li>\n</ul>\n</div>\n<div class=\"content\">\n<h3>Herramientas para la producción</h3>\n<p>Los contenedores son herramientas divertidas para usar en el desarrollo, pero el mejor caso de uso para ellos es en el entorno de producción. Hay muchas herramientas más potentes que docker-compose para ejecutar contenedores en producción.</p>\n<p>Herramientas de orquestación de contenedores pesados como <a href=\"https://kubernetes.io/\">Kubernetes</a> nos permiten administrar contenedores en un nivel completamente nuevo. Estas herramientas ocultan las máquinas físicas y nos permiten a nosotros, los desarrolladores, preocuparnos menos por la infraestructura.</p>\n<p>Si está interesado en obtener más información sobre los contenedores, acceda al curso <a href=\"https://devopswithdocker.com\">DevOps con Docker</a> y podrá encontrar más información sobre Kubernetes en el curso avanzado de 5 créditos <a href=\"https:%20//devopswithkubernetes.com\">DevOps con Kubernetes</a> curso. ¡Ahora deberías tener las habilidades para completar ambos!</p>\n</div>\n<div class=\"tasks\">\n<h3>Ejercicios 12.20.-12.22.</h3>\n<h4>Ejercicio 12.20:</h4>\n<p>Cree una producción <i>todo-app/docker-compose.yml</i> con todos los servicios, Nginx, todo-backend, todo-frontend, MongoDB y Redis. Utilice Dockerfiles en lugar de <i>dev.Dockerfiles</i> y asegúrese de iniciar las aplicaciones en modo de producción.</p>\n<p>Utilice la siguiente estructura para este ejercicio:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">todo-app\n├── todo-frontend\n├── todo-backend\n├── nginx.conf\n├── docker-compose.dev.yml\n<span class=\"gatsby-highlight-code-line\">└── docker-compose.yml</span></code></pre></div>\n<h4>Ejercicio 12.21:</h4>\n<p>Cree un entorno de desarrollo en contenedores similar para uno de sus aplicaciónes <i>propias</i> puede usar las que haya creado durante el curso o en su tiempo libre. Debe estructurar la aplicación en su repositorio de envío de la siguiente manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">└── my-app\n    ├── frontend\n    <span class=\"token operator\">|</span>    └── dev.Dockerfile\n    ├── backend\n    <span class=\"token operator\">|</span>    └── dev.Dockerfile\n    └── docker-compose.dev.yml</code></pre></div>\n<h4>Ejercicio 12.22:</h4>\n<p>Termine esta parte creando una <i>configuración de producción</i> en contenedores de su propia aplicación.\nEstructure la aplicación en su repositorio de envío de la siguiente manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">└── my-app\n    ├── frontend\n    <span class=\"token operator\">|</span>    ├── dev.Dockerfile\n    <span class=\"token operator\">|</span>    └── Dockerfile\n    ├── backend\n    <span class=\"token operator\">|</span>    └── dev.Dockerfile\n    <span class=\"token operator\">|</span>    └── Dockerfile\n    ├── docker-compose.dev.yml\n    └── docker-compose.yml</code></pre></div>\n<h3>Envío de ejercicios y obtención de créditos.</h3>\n<p>Este fue el último ejercicio de esta sección. Es hora de enviar su código a GitHub y marcar todos sus ejercicios terminados en el <a href=\"https://studies.cs.helsinki.fi/stats/courses/fs-containers\">sistema de envío de ejercicios</a>.</p>\n<p>Los ejercicios de esta parte se envían al igual que en las partes anteriores, pero a diferencia de las partes 0 a 7, la presentación va a una <a href=\"https://studies.cs.helsinki.fi/stats/courses/fs-containers\">instancia propia del curso</a>. ¡Recuerda que tienes que terminar <i>todos los ejercicios</i> para aprobar esta parte!</p>\n<p>Una vez que hayas completado los ejercicios y quieras obtener los créditos, infórmanos a través del sistema de envío de ejercicios que has completado el curso:</p>\n<picture><img src=\"/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/5a190/21.png\" alt=\"Submissions\" srcset=\"/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/772e8/21.png 200w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/e17e5/21.png 400w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/5a190/21.png 800w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/c1b63/21.png 1200w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/29007/21.png 1600w,\n/static/d2a0d8c8142ce4113bdf5bfec2d1dd37/74e37/21.png 1732w\" sizes=\"(max-width: 800px) 100vw, 800px\"></picture>\n<p><strong>Tenga en cuenta</strong> que necesita registrarse en la parte del curso correspondiente para obtener los créditos registrados, consulte <a href=\"/es/part0/informacion_general#partes-y-finalizacion\">aquí</a> para obtener más información.</p>\n<p>Puede descargar el certificado por completar esta parte haciendo clic en uno de los íconos de bandera. El ícono de la bandera corresponde al idioma del certificado.</p>\n</div>\n</div>","frontmatter":{"mainImage":{"publicURL":"/static/09ec6709015c0dcb492111bd9e645d3d/part-12.svg"},"part":12,"letter":"c","lang":"es"}}},"pageContext":{"part":12,"letter":"c","lang":"es"}},"staticQueryHashes":["3128451518"]}